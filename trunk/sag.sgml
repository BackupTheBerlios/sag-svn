<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.2//EN">

<book>
  <bookinfo>
   <date>$Date: 1999/07/29 07:49:53 $</date>
    <graphic fileref="gwiazda"/>
	<title>The Linux System Administrators' Guide</title>
    <subtitle>Wersja 0.6.2</subtitle>
    <author>
    	<firstname>Lars</firstname>
    	<surname>Wirzenius</surname>
	<affiliation>
		<address>
		<email>liw@iki.fi</email>
		</address>
	</affiliation>
    </author>
    <author>
    	<firstname>Joanna</firstname>
    	<surname>Oja</surname>
	<affiliation>
		<address>
		<email>viu@iki.fi</email>
		</address>
	</affiliation>
    </author>

<abstract> <para>  Wstêp do administracji systemem Linux.</para> </abstract>

    <legalnotice>

<para>  Copyright 1993--1998 Lars Wirzenius.</para>

<para>  Wszelkie znaki towarowe zastrze¿one dla ich w³a¶cicieli.</para>

<para>  Zezwala siê na kopiowanie i rozprowadzanie ca³ego podrêcznika
	przy spe³nionym warunku w³±czenia informacji o copyright i
    tego powiadomienia.</para>

<para>  Zezwala siê na przetwarzanie nastêpuj±cego tekstu programem TeX,
    lub innym programem formatuj±cym, na wydrukowanie rezultatu
    i dystrybucjê wydrukowanego dokumentu pod warunkiem za³±czenia
    informacji o licencji w postaci niezmienionej, w³±czaj±c informacje
    o po³o¿eniu kodu ¼ród³owego i oficjalnej strony domowej.
	</para>

<para>  Zezwala siê na kopiowanie i rozprowadzanie zmodyfikowanych
    wersji tego podrêcznik pod warunkiem, ¿e zmieniony produkt
    bêdzie rozprowadzany na tej samej licencji.
	</para>

<para>  Zezwala siê na kopiowanie i rozprowadzanie t³umaczeñ
    tego dokumentu pod warunkami dotycz±cymi zmienionych wersji.
	</para>

<para>  Autor bêdzie wdziêczny za informacje na temat zmian,
    t³umaczeñ, oraz wydrukowanych wersji. Dziêkujê.</para>

    </legalnotice>
    
  </bookinfo>
  
  <toc></toc>

<preface>
<title>Dedykacja</title>

<para> Miejsce to dedykujê przysz³ej dedykacji.</para>

</preface>

<preface>
<title>Od t³umacza, linki do plików</title>
<para>
    T³umaczenia dokona³ Pawe³ Niewiadomski (new (at) foo (kreska) baz (kropka) com).
</para>
<para>
	Rób z tym t³umaczeniem cokolwiek chcesz tak d³ugo jak spe³nione s±
	oryginalne warunki postawione przez autora. Je¿eli jeste¶ na tyle
	mi³y daj mi znaæ o swoich poczynaniach.
</para>
<para>
    T³umaczenie nie bêdzie przeze mnie rozwijane, czy uaktualniane, dlatego je¿eli
    masz czas, chêci i wiedzê (najwa¿niejsze s± chêci i czas :-) mo¿esz 
	utworzyæ konto na serwerze <ulink url="http://developer.berlios.de">http://developer.berlios.de</ulink>
	i zacz±æ modyfikowaæ znajduj±ce siê tam ¼ród³a (t³umaczenie trzymane
	jest w repozytorium, ka¿dy kto zechce dostanie do niego dostêp, tak samo
	do strony, itp.).
</para>
<para>
    Dziêki tym panom parê b³êdów przesta³o istnieæ:
	<itemizedlist>
    	<listitem>
			<para>Roman Kamiñski (<ulink url="mailto:romank@linuxpl.org">romank@linuxpl.org</ulink>),</para></listitem>
    	<listitem>
			<para>Wojtek Kotwica (<ulink url="mailto:wkotwica@post.pl">wkotwica@post.pl</ulink>),</para></listitem>
    	<listitem>
			<para>Marek Ró¿añski.</para></listitem>
	</itemizedlist>
</para>
<para>
	<emphasis>
	Pod nastêpuj±cym adresem mo¿na ¶ci±gn±æ ¼ród³a, wersjê HTML oraz
	wersjê RTF:
    <ulink url="https://developer.berlios.de/project/showfiles.php?group_id=5324">https://developer.berlios.de/project/showfiles.php?group_id=5324</ulink>
	</emphasis>
</para>
</preface>

<preface>
<title>Wersje: ¼rod³owa i preformatowane</title>

<para>  Dokument w postaci ¼ród³owej i innych odczytywalnych
	formatach znajduje siê na stronie domowej projektu tworzenia
	dokumentacji: "Linux Documentation Project", pod adresem <ulink
	url="http://sunsite.unc.edu/LDP/">http://sunsite.unc.edu/LDP/</ulink>,
	oraz na stronie domowej autora <ulink
	url="http://www.iki.fi/viu/linux/sag/">http://www.iki.fi/viu/linux/sag/</ulink>.
	Dostêpne w formatach: Postscript i TeX .DVI.
	T³umaczenie dokumentu znajduje siê pod adresem <ulink url="http://www.linuxpl.org/SAG">http://www.linuxpl.org/SAG
	</ulink></para>
</preface>

<chapter>
<title>Wstêp</title>

<blockquote><para><quote> Na pocz±tku dokument by³ bez kszta³tu i 
	tre¶ci; bity reprezentowa³y pustkê. Palce Autora przenios³y siê
	nad klawiaturê. I Autor powiedzia³: niech powstan± s³owa,
	i tak siê sta³o.</quote></para></blockquote>

	<para> Ten podrêcznik: "Linux System Administrators' Guide"
	opisuje aspekty administracji systemu Linux.
	Kierowany jest do ludzi, którzy wiedz± niewiele o administracji
	( na poziomie "co to?" ), ale jednak znaj± podstawy normalnego
	korzystania z systemu. Podrêcznik nie powie Ci jak zainstalowaæ
	któr±kolwiek z dystrybucji Linuxa; jest to opisane w innych
	dokumentach. Poni¿ej znajduje siê wiêcej informacji na temat
	dokumentacji.</para>

	<para> Administracja systemem to wszelkie czynno¶ci maj±ce na
	celu utrzymanie systemu w u¿ywalnym stanie. Zawiera takie
	rzeczy jak tworzenie kopii zapasowych (u¿ywanie ich je¿eli
	trzeba), instalowanie nowych programów, tworzenie kont
	(usuwanie niepotrzebnych), sprawdzanie systemu plików, itp., itd.
	Gdyby komputer by³ domem administracja mog³aby byæ nazwana
	konserwacj± i zawiera³aby sprz±tanie, wymianê szyb i inne podobne
	rzeczy. Administracja nie jest zwana konserwacj± poniewa¿
	by³oby to zbyt du¿e uproszczenie.
		
<footnote><para>  Istniej± ludzie, którzy j± tak
		<emphasis>nazywaj±</emphasis>, dzieje siê tak dlatego, i¿
		nigdy nie przeczytali tego¿ podrêcznika. Biedactwa.
		</para></footnote>
	
	</para>

<para>  Podrêcznik zbudowany jest modu³owo - rozdzia³y s± niezale¿nymi
	ca³o¶ciami, nie musisz znaæ innych aby zrozumieæ rozdzia³, który
	czytasz. W ten sposób mo¿esz zagl±daæ do podrêcznika w poszukiwaniu
	odpowiedzi na dane pytania. Mo¿esz siê do niego odwo³ywaæ w razie
	potrzeby. Podrêcznik zosta³ stworzony jako wprowadzenie do tematu,
	zbieg okoliczno¶ci sprawi³, ¿e sta³ siê referencyjny.
	</para>

<para>  Podrêcznik ten nie jest wyroczni± - istnieje wiele innych
	dokumentów, do których nale¿a³oby zajrzeæ. Bardzo wa¿nym ¼ród³em
	informacji s± podrêczniki (manuale), do których nale¿y zagl±daæ
	po informacje na temat nieznanego polecenia.
	</para>

<para>  Podrêcznik ukierunkowany jest na Linuxa, jednak ogólne zasady
	dotycz± wszystkich systemów Unix. Niestety miêdzy ró¿nymi wersjami
	Unixa istniej± znacz±ce ró¿nice, które uniemo¿liwiaj± g³êbsze 
	omawianie. Nawet omawianie wszystkich mo¿liwo¶ci Linuxa jest
	bardzo trudne, z powodu schematu tworzenia aplikacji.
	</para>
	
<para>  Nie istnieje ¿adna oficjalna dystrybucja Linuxa,
	wiêc ró¿ni ludzie maj± ró¿ne ustawienia, niektórzy potworzyli
	w³asne. Ksi±¿ka nie jest nastawiona na ¿adn± z dystrybucji,
	chocia¿ osobi¶cie u¿ywam Debian GNU/Linux. Stara³em siê
	ukazywaæ ró¿nice miêdzy dystrybucjami oraz omawiaæ alternatywy.
	</para>
	
<para>  Stara³em siê opisywaæ naturê rzeczy, a nie prosty algorytm
	w stylu "raz dwa trzy". Oznacza to, ¿e wiele informacji oka¿e
	siê dla Ciebie zbêdnymi, czê¶ci takie oznaczone s± jako "do
	przeskoczenia". Przeczytanie wszystkiego nauczy Ciê wiele,
	uczyni administracjê przyjemniejsz±.
	</para>

<para>  Tak jak ka¿dy inny projekt twórczy zwi±zany z Linuxem
	praca ta powsta³a bez przymusu: zrobi³em to poniewa¿ uwa¿a³em,
	¿e sprawi mi to rado¶æ, uwa¿a³em, i¿ nale¿y to zrobiæ.
	Jednak¿e, tak jak ka¿da praca ochotnicza podrêcznik jest ograniczony
	limitem wiedzy i mo¿liwo¶ci. Oznacza to, i¿ ksi±¿ka mo¿e nie 
	sprostaæ konkurencji z dzie³em pisanym przez wiele lat, przez 
	dobrze op³aconego twórcê. Osobi¶cie uwa¿am, ¿e jest ca³kiem niez³a,
	jednak ostrzeg³em Ciê.
	</para>

	<para> Nie opisywa³em rzeczy, o których mowa w innych darmowych
	podrêcznikach. Dotyczy to zw³aszcza dokumentacji programów,
	np. brak szczegó³owego opisu programu <command>mkfs</command> -
	opisujê tylko sferê u¿yteczno¶ci i opcje na miarê potrzeb
	podrêcznika. Aby dowiedzieæ siê wiêcej nale¿y zajrzeæ do podrêczników,
	których zestaw rozprowadzany jest z ka¿d± dystrybucj±.
	</para>

	<para> Lars stara³ siê uczyniæ podrêcznik najlepszym jak tylko
	móg³. Ja, jako aktualny opiekun, chcia³bym podtrzymaæ tradycjê.
	Chcia³bym us³yszeæ o wszystkim, co mo¿e uczyniæ ten dokument
	lepszym. B³êdy ortograficzne, merytoryczne, nowe pomys³y,
	nowe rozdzia³y, informacje na temat ró¿nic miêdzy wersjami Unixa,
	jestem zainteresowany tym wszystkim. Wiêcej informacji
	znajduje siê pod adresem <ulink url="http://www.iki.fi/viu/">
	http://www.iki.fi/viu/</ulink>.
	</para>
	
	<para> Pomog³o mi wielu ludzi - bezpo¶rednio i po¶rednio. Specjalne
	podziêkowania kierujê do Matta Welsha za inspiracjê i kierowanie
	projektem LDP, Andy'iemu Oramowi za ponowne zatrudnienie mnie na
	godziwych warunkach, Olafowi Kirch za przekonanie mnie, ¿e jest
	to mo¿liwe oraz Adamowi Richterowi z Yggdrasil i innym za
	to, ¿e uwa¿aj± tê ksi±¿kê za interesuj±c±.</para>
	
	<para> Stephen Tweedie, H. Peter Anvin, Remy Card, Theodore
	Ts'o i Stephen Tweedie pozwolili mi skorzystaæ z ich dorobku
	(co uczyni³o ksi±¿kê grubsz± i bardziej imponuj±c±):
	porównanie systemów plików: xia i ext2, lista urz±dzeñ, opis
	funkcjonowania systemu ext2. Nie s± one ju¿ czê¶ci± podrêcznika.
	Jestem za to niemal wdziêczny i pokornie przepraszam, ¿e poprzednie
	wersje czasami nie wspomina³y o przynale¿nych prawach.
	</para>

	<para> Dodatkowo, chcê podziêkowaæ Markowi Komaryñskiemu 
	(w oryginale: Komarinski) za przys³anie mi w 1993 roku materia³ów,
oraz za wiele artuku³ów w dziale "administracja systemem" Linux Journal.
	By³y one pouczaj±ce i inspiruj±ce.
	</para>

	<para> Wiele u¿ytecznych komentarzy otrzyma³em od rzeszy ludzi.
	Ma³a dziura w moim archiwum nie pozwala mi zamie¶ciæ wszystkich
	nazwisk, jednak oto pozosta³e z nich (w porz±dku alfabetycznym):
	Paul Caprioli, Ales Cepek, Marie-France Declerfayt,
	Dave Dobson, Olaf Flebbe, Helmut Geyer, Larry Greenfield and
	his father, Stephen Harris, Jyrki Havia, Jim Haynes, York Lam,
	Timothy Andrew Lister, Jim Lynch, Michael J. Micek, Jacob Navia,
	Dan Poirier, Daniel Quinlan, Jouni K Seppänen, Philippe Steindl,
	G.B. Stotte. Przepraszam wszystkich pominiêtych.</para>


<sect1>
<title>The Linux Documentation Project</title>

	<para> The Linux Documentation Project, w skrócie LDP, 
	jest zespo³em pisarzy, korektorów oraz edytorów, którzy pracuj±
	razem aby stworzyæ kompletn± dokumentacjê systemu operacyjnego Linux.
	G³ównym koordynatorem jest Greg Hankins.</para>

	<para> Podrêcznik ten rozprowadzany jest przez LDP, tak jak
	nastêpuj±ce pozycje: Linux Users' Guide,
	System Administrators' Guide, Network Administrators' Guide,
	Kernel Hackers' Guide. Wszystkie te podrêczniki dostêpne s± w postaci
	¼ród³owej, dvi, postscript poprzez anonimowe FTP z sunsite.unc.edu, katalog
	<filename>/pub/Linux/docs/LDP</filename>.</para>

	<para> Zachêcamy wszelkich chêtnych z zaciêciem pisarskim do 
	przy³±czenia siê. Skontaktuj siê z Gregiem Hankins <email>gregh@sunsite.unc.edu</email>.
	</para>

</sect1>

</chapter>


<chapter>
<title>Wprowadzenie do Linuxa</title>

	<blockquote><para> <quote>Bóg spojrza³ na wszystko co uczyni³
	i zobaczy³, ¿e jest to dobre.</quote> (Ksiêga Rodzaju 1:31)</para></blockquote>

	<para> Nastêpuj±cy rozdzia³ zawiera przegl±d systemu Linux.
    Na pocz±tku omawiane s± g³ówne us³ugi pracuj±ce w systemie oraz
    programy ¶wiadcz±ce je - minimum szczegó³ów. Zadaniem tej czê¶ci
    jest zapoznanie siê z systemem jako ca³o¶ci±, ka¿da z czê¶ci
    zostanie pó¼niej omówiona.</para>

<sect1>
<title>Ró¿ne czê¶ci systemu operacyjnego</title>

	<para> System operacyjny UNIX sk³ada siê z 
	<glossterm>j±dra</glossterm> oraz
	<glossterm>programów systemowych</glossterm>.  Dostêpne s± równie¿
	ró¿ne <glossterm>aplikacje</glossterm>.
	J±dro jest sercem systemu operacyjnego.
	
		<footnote><para> Czêsto jest ono b³êdnie nazywane systemem operacyjnym.
        System operacyjny udostêpnia du¿o wiêcej us³ug ni¿ samo j±dro.</para>
		</footnote>
		
	To ono wyszukuje pliki na dysku, uruchamia programy i rozdziela
    czas CPU, udostêpnia pamiêæ i inne zasoby, odbiera i wysy³a pakiety 
    sieciowe, itd. J±dro robi niewiele, jednak dostarcza podstaw
    umo¿liwiaj±cych tworzenie narzêdzi. Nie dopuszcza, by ktokolwiek mia³ bezpo¶redni
    dostêp do sprzêtu, zmuszaj±c wszystkich do u¿ywania dostarczonych
    funkcji. W ten sposób j±dro do pewnego stopnia chroni jednego u¿ytkownika przed drugim.
    J±dro udostêpnia swe funkcje poprzez mechanizm <glossterm>wywo³añ 
    systemowych</glossterm>; zobacz strony podrêcznika z sekcji 2.</para>

	<para> Programy systemowe u¿ywaj± narzêdzi dostarczonych przez 
    j±dro w celu implementacji ró¿nych wymaganych przez system operacyjny
    us³ug. Wszelkie programy pracuj± 'na j±drze', w <glossterm>trybie
u¿ytkownika</glossterm>. Jedn± z ró¿nic miêdzy programami systemowymi
    a aplikacjami jest to, ¿e aplikacje udostêpniaj± ró¿ne u¿yteczne
    rzeczy (np. mo¿liwo¶æ grania, je¿eli jest to gra), natomiast
    programy systemowe s± niezbêdne do poprawnej pracy systemu.
Procesor tekstu jest aplikacj±; <command>telnet</command> jest
    programem systemowym. Ró¿nica jest czêsto umowna, potrzebna tylko
    dla zatwardzia³ych klasyfikatorów.
	</para>

<para> System operacyjny czêsto zawiera kompilatory i odpowiednie
    biblioteki (GCC i biblioteka C), przy czym nie wszystkie jêzyki
    programowania musz± byæ czê¶ci± systemu. Dokumentacja i np.
    gry równie¿ mog± ni± byæ (przyp. t³um. w tym wypadku sk³ania³bym siê 
    do terminu dystrybucja). Tradycyjnie, system operacyjny 
    definiowany by³ przez zawarto¶æ medium instalacyjnego,
    w przypadku Linuxa tak nie jest - wiele komputerów 
    udostêpnia poprzez FTP ró¿norakie 'czê¶ci' systemu.</para>

</sect1>

<sect1>
<title>Wa¿ne czê¶ci j±dra</title>

	<para> J±dro Linuksa zawiera kilka podstawowych czê¶ci: zarz±dzanie
    procesami, pamiêci±, sterowniki urz±dzeñ, obs³uga systemu plików,
    zarz±dzanie sieci± i wiele innych.
	<xref linkend="kerneloverview"/>
	pokazuje je.</para>

		<figure id="kerneloverview" float="1">
		<title>Kilka z najwa¿niejszych czê¶ci Linuksa</title>
		<graphic fileref="overview-kernel"></graphic>
		</figure>

	<para> Najprawdopodobniej najwa¿niejszymi czê¶ciami j±dra (bez nich
    nie dzia³a nic) s± modu³y zarz±dzania pamiêci± i procesami.
	Zarz±dzanie pamiêci± polega na przypisywaniu obszarów pamiêci
    fizycznej i swapu procesom, czê¶ciom j±dra, oraz cache'owi urz±dzeñ
    blokowych. Zarz±dzanie procesami polega na ich tworzeniu i implementacji
    wielozadaniowo¶ci poprzez zmianê aktywnie wykonywanego.
	</para>

	<para> Na najni¿szym poziomie j±dro zawiera sterowniki obs³ugiwanych 
    urz±dzeñ. Poniewa¿ ¶wiat jest pe³ny ró¿norakiego sprzêtu jest ich
    wiele. Istnieje wiele podobnych do siebie urz±dzeñ ró¿ni±cych siê
    w warstwie programowej. Te podobieñstwo pozwala pogrupowaæ sterowniki;
    w ten sposób cz³onek danej klasy ma ustalony interfejs programowy,
    ró¿ni siê natomiast wewnêtrzn± komunikacj± miêdzy sprzêtem a j±drem.
    Np. wszystkie sterowniki dysków posiadaj± funkcje do: inicjalizacji,
    odczytania, lub zapisania podanego sektora.
	</para>

	<para> Niektóre us³ugi oferowane przez j±dro maj± podobne w³a¶ciwo¶ci,
    dziêki temu mog± zostaæ podzielone w abstrakcyjne klasy.
	Dla przyk³adu, ró¿ne protoko³y sieciowe zosta³y po³±czone w jednym
    interfejsie programistycznym, bibliotece gniazd BSD. Innym przyk³adem
    jest <glossterm>wirtualny system plików</glossterm> (VFS),
    który obs³uguje operacje plikowe niezale¿nie od systemu plików.
    Je¿eli jaki¶ proces chce skorzystaæ z systemu plików wszelkie ¿±dania
    kierowane s± do VFS, który nastêpnie przekierowuje je do odpowiedniego
    sterownika.</para>

</sect1>

<sect1>
<title>Podstawowe us³ugi w systemie UNIX</title>

	<para> Sekcja opisuje kilka z najwa¿niejszych us³ug oferowanych
    w Uniksie, nie omawia szczegó³ów (znajdziesz je w dalszych czê¶ciach
    ksi±¿ki). 
	</para>

<sect2>
<title><command>init</command></title>

	<para> Jedna z najwa¿niejszych us³ug w systemie Unix oferowana
    jest przez program <command>init</command>.  <command>init</command>
	jest pierwszym uruchomionym przez j±dro procesem, ostatnim stadium
    bootowania j±dra. <command>init</command> po uruchomieniu dokañcza
    proces bootowania poprzez wykonanie odpowiednich skryptów (np.
    zawieraj±cych sprawdzenie i zamontowanie systemów plików, uruchomienie
    demonów).</para>

	<para> Dok³adna lista czynno¶ci wykonywanych przez <command>init</command>
	ró¿ni siê zale¿nie od systemu.
	<command>init</command> zazwyczaj udostêpnia <glossterm>tryb jednego
    u¿ytkownika</glossterm>, w którym nikt nie mo¿e siê zalogowaæ, a root
    korzysta z pow³oki na konsoli; normalnie system pracuje w 
	<glossterm>trybie wielu u¿ytkowników</glossterm>. W niektórych systemach
    istnieje podzia³ na <glossterm>poziomy pracy</glossterm>; tryb
    jednego u¿ytkownika i wielu u¿ytkowników to dwa poziomy pracy,
    mog± istnieæ równie¿ dodatkowe, np. tryb, w którym X jest domy¶lnie
    uruchamiane.</para>

	<para> Podczas normalnego dzia³ania <command>init</command> sprawdza
    czy dzia³a <command>getty</command> (aby umo¿liwiæ u¿ytkownikom
    zalogowanie), adoptuje osierocone procesy (których rodzic umar³;
	w Uniksie <emphasis>wszystkie</emphasis> procesy <emphasis>musz±</emphasis>
	tworzyæ pojedyncze drzewo - sieroty musz± byæ adoptowane).
    </para>

	<para> Podczas zamykania systemu <command>init</command> jest odpowiedzialny
    za zabicie wszystkich procesów, oraz inne skonfigurowane rzeczy.
	</para>

</sect2>

<sect2>
<title>Logowanie z terminala</title>

	<para> Logowanie z terminala (via ³±cza szeregowe) oraz konsolê
	(je¿eli X nie dzia³a) obs³ugiwane jest przez program
    <command>getty</command>.  <command>init</command> dla ka¿dego
    z terminali uruchamia osobny proces <command>getty</command>.
    <command>getty</command> odczytuje  nazwê u¿ytkownika
    po czym uruchamia program <command>login</command>,
	który odczytuje has³o.  Je¿eli nazwa u¿ytkownika i has³o
	s± poprawne, <command>login</command> uruchomi pow³okê.
	Po zakoñczeniu pracy pow³oki (wylogowaniu siê u¿ytkownika), lub
    w przypadku niezgadzaj±cego siê has³a <command>init</command>
    uruchomi nowy proces <command>getty</command>.
	J±dro nie wie co to "logowanie siê", jest to zale¿ne od programów
    systemowych.</para>

</sect2>

<sect2>
<title>Syslog</title>

	<para> J±dro oraz programy systemowe produkuj± b³êdy, ostrze¿enia i 
    inne wiadomo¶ci. Czasami wymaga siê aby by³a mo¿liwo¶æ pó¼niejszego
    przegl±du tych wiadomo¶ci, wiêc powinny byæ zapisywane do pliku.
	Troszczy siê o to <command>syslog</command>.  Mo¿na go skonfigurowaæ
    do sortowania wiadomo¶ci, odrzucania, lub zapisywania wymaganych, 
    zapisywania wiadomo¶ci do kilku plików ze wzglêdu na wa¿no¶æ, itp.
	Np. wiadomo¶ci wysy³ane przez j±dro s± najczê¶ciej zapisywane do
    osobnego pliku, poniewa¿ s± one czêsto wa¿niejsze i powinny byæ
    regularnie czytane, by dostrzec k³opoty.
	</para>
	
</sect2>

<sect2>
<title>Okresowe wykonywanie poleceñ: <command>cron</command> i
<command>at</command></title>

	<para> U¿ytkownicy i administratorzy systemu czêsto musz± wykonywaæ
    polecenia co pewien okres. Dla przyk³adu: administrator
    móg³by chcieæ czy¶ciæ co okre¶lony czas katalogi zawieraj±ce pliki tymczasowe
    (<filename>/tmp</filename> i <filename>/var/tmp</filename>).
    Zapobiega to przepe³nieniu dysku, gdy¿ nie wszystkie programy poprawnie
    sprz±taj± po sobie.</para>

	<para> W tym celu powsta³ program <command>cron</command>.
    Ka¿dy u¿ytkownik posiada swój plik <filename>crontab</filename>, w
    którym mo¿na zapisywaæ instrukcje uruchamiania okresowego.
    Demon <command>cron</command> troszczy siê o to aby wykonaæ dane
    polecenie o wskazanym czasie.</para>

	<para> Polecenie <command>at</command> jest podobne do
	programu <command>cron</command>, ró¿ni siê tym, ¿e polecenie
    jest uruchamiane tylko raz, w zadanym terminie; nie jest powtarzane.
	</para>

</sect2>

<sect2>
<title>Graficzny interfejs u¿ytkownika</title>

	<para> UNIX i Linux nie wbudowuj± interfejsu u¿ytkownika
	w j±dro; przeciwnie - interfejs dostarczany jest przez ró¿ne
    programy. Odnosi siê to do trybu tekstowego i graficznego,
	</para>

	<para> Takie podej¶cie czyni system bardziej elastycznym,
    posiada jednak równie¿ wadê - u³atwia to tworzenie ró¿norakich
    interfejsów, których mnogo¶æ stanowi barierê w poznawaniu systemu.
	</para>

	<para> Graficzne ¶rodowisko u¿ytkownika dostêpne w Linuksie nazywa siê:
    X Window System (krótko: X).  X nie implementuje interfejsu
    u¿ytkownika; jest on odpowiedzialny za system okna, narzêdzi,
    dziêki którym mo¿na opracowaæ interfejs graficzny.
    Trzy najpopularniejsze style interfejsów to:
	Athena, Motif i Open Look.</para>

</sect2>

<sect2>
<title>Sieæ</title>

	<para> Sieæ jest to akt ³±czenia co najmniej dwóch komputerów
    w sposób umo¿liwiaj±cych ich wzajemn± komunikacjê.
	Aktualne metody ³±czenia i komunikacji s± wewnêtrznie skomplikowane,
    jednak u¿ytkownikowi dostarczona jest u¿yteczna otoczka.
	</para>

	<para> Unix jest systemem sieciowym.
	Wiêkszo¶æ podstawowych us³ug (systemy plików, drukowanie, kopie zapasowe)
    mo¿e byæ wykonywana przez sieæ. U³atwia to administracjê systemem, gdy¿
    pozwala na scentralizowan± administracjê, przy równoczesnym korzystaniu
    z dobrodziejstw mikroprzetwarzania i rozproszonego przetwarzania, jak
    ni¿sze koszty czy lepsza odporno¶æ na b³êdy.</para>

	<para> Ksi±¿ka zawiera tylko podstawowe wiadomo¶ci na temat sieci; 
    zobacz <citetitle>Linux Network Administrators' Guide</citetitle>,
    który zawiera wiêcej informacji, w³±czaj±c zasady dzia³ania sieci.
	</para>

</sect2>

<sect2>
<title>Zdalne logowanie siê</title>

	<para> Zdalnie logowanie dzia³a nieco inaczej ni¿ normalne.
	Dla ka¿dej fizycznej linii istnieje osobny terminal, przez który
    mo¿na siê po³±czyæ. Dla ka¿dego zdalnego logowania istnieje
    wirtualne po³±czenie sieciowe, mo¿e ich byæ dowolnie du¿o.
	
		<footnote><para> A co najmniej wiele. Przepustowo¶æ sieci
        stanowi nadal jest nadal zasobem ograniczonym, wiêc istnieje pewien
        faktyczny limit jednoczesnych logowañ poprzez jedno po³±czenie
        sieciowe.
		</para></footnote>
		
	Z tego powodu nie jest mo¿liwe uruchomienie osobnego <command>getty</command>
    dla ka¿dego po³±czenia wirtualnego.
	Istnieje te¿ kilka innych mo¿liwo¶ci zdalnego zalogowania siê,
        z których najczê¶ciej wykorzystywane w sieciach TCP/IP s±
	<command>telnet</command>, <command>rlogin</command> oraz <command>
    ssh</command>.</para>

	<para> Dla tego typu logowañ, zamiast stada procesów
	<command>getty</command>, istnieje pojedynczy demon
	(obs³uguj±cy <command>telnet</command> i <command>rlogin</command>
    maj± odrêbne demony), który czeka na po³±czenia.
    Je¿eli takie nastêpuje, uruchamia swoj± kopiê, która bêdzie
    odpowiedzialna za obs³u¿enie danego po³±czenia; oryginalny proces 
    nas³uchuje dalej.
	</para>

</sect2>
<sect2>
<title>Sieciowe systemy plików</title>

	<para> Jedn± z bardziej u¿ytecznych rzeczy, które mo¿na zrobiæ przez
    sieæ jest udostêpnianie dysków za po¶rednictwem
    <glossterm>sieciowego systemu plików</glossterm>. Najczê¶ciej
    u¿ywa siê protoko³u Network File System (NFS), stworzonego przez
    Sun-a.</para>

	<para> Za pomoc± takiego systemu plików wszelkie operacje plikowe
    wykonywane przez program na jednym komputerze przesy³ane s± przez sieæ
    i wykonywane na innym. Oszukanemu programowi wydaje siê, ¿e wszystkie
    pliki obcego komputera znajduj± siê na tej maszynie, na której go
    uruchomiono. Powoduje to, ¿e wspó³dzielenie danych jest niezwykle ³atwe,
    gdy¿ nie trzeba w ogóle zmieniaæ programów.
    </para>

</sect2>

<sect2>
<title>Poczta</title>

	<para> Poczta elektroniczna jest najwa¿niejsz± metod± komunikacji za
    pomoc± komputera. Elektroniczny list przechowywany jest za pomoc±
    pliku o specjalnym formacie, a do jego przetwarzania s³u¿± specjalne
    programy.
	</para>

	<para> Ka¿dy u¿ytkownik posiada <glossterm>skrzynkê pocztow±</glossterm>
	(plik lub katalog w odpowiednim formacie), w której umieszczane s±
    pliki z poczt±. Kiedy kto¶ wysy³a pocztê program lokalizuje
    komputer zawieraj±cy skrzynkê odbiorcy, po czym przesy³a wiadomo¶æ.
	</para>

	<para> System pocztowy sk³ada siê z wielu programów. 
    Do³±czaniem wiadomo¶ci do skrzynek u¿ytkowników zajmuje siê
    jeden program (<glossterm>agent transferu poczty</glossterm>, inaczej
    <glossterm>MTA</glossterm>, np. <command>qmail</command>,
	<command>postfix</command>), natomiast u¿ytkownicy korzystaj± z wielu
	ró¿nych programów do czytania (<glossterm>agentów poczty u¿ytkownika</glossterm>,
	<glossterm>MUA</glossterm>, np. <command>pine</command>,
	<command>mutt</command>). Zazwyczaj poczta przychodz±ca przechowywana jest w
    <filename>/var/spool/mail</filename>.</para>

</sect2>

<sect2>
<title>Drukowanie</title>

	<para> W danym momencie tylko jedna osoba mo¿e korzystaæ z drukarki,
	jednak nieekonomicznym jest przydzielanie jej u¿ytkownikowi
	na wy³±czno¶æ.
    Drukark± zarz±dza specjalne oprogramowanie
    implementuj±ce <glossterm>kolejkê drukowania</glossterm>: wszystkie
    ¿±dania wydruku umieszczane s± w kolejce, po zakoñczeniu jednej pracy
    wykonywana jest nastêpna. Dziêki temu u¿ytkownicy nie musz± walczyæ
    o dostêp do drukarki.
	
		<footnote><para> W zamian, tworz± kolejkê <emphasis>przy</emphasis>
        drukarce czekaj±c na swój wydruk, poniewa¿ niewiele osób
        jest w stanie sprawdziæ czy drukowanie zosta³o wykonane.
        Dziêki temu gwa³towanie wzrasta wewn±trz-firmowe ¿ycie towarzyskie.
		</para></footnote>
	
	</para>

	<para> Oprogramowanie kolejkuj±ce <glossterm>buforuje</glossterm> na dysku
	gotowe do druku prace. Umo¿liwia to programom przekazanie dokumentu
    do programu odpowiedzialnego za drukowanie i powrót do pracy -
    aplikacja nie musi czekaæ na faktyczne zakoñczenie drukowania.
    Jest to naprawdê wygodne, gdy¿ pozwala wys³aæ do wydrukowania aktualn±
    wersjê dokumentu i nie czekaj±c na zakoñczenie, rozpocz±æ tworzenie
    nowej wersji.
    </para>

</sect2>

<sect2>
<title>Struktura systemu plików</title>

	<para> System plików podzielony jest na wiele czê¶ci;
    najczê¶ciej g³ówny system plików zawiera
	<filename>/bin</filename>, <filename>/lib</filename>,
	<filename>/etc</filename>, <filename>/dev</filename> i kilka innych;
     katalog <filename>/usr</filename> z niezmiennymi danymi i programami;
	katalog <filename>/var</filename> z czêsto zmienianymi plikami
	(np. logi) oraz	<filename>/home</filename> zawieraj±cy katalogi
    domowe u¿ytkowników. Zale¿nie od decyzji administratora 
    struktura mo¿e byæ ró¿na, wszystko mo¿e znajdowaæ siê jednej partycji,
    lub wielu, itd.
	</para>

	<para> <xref linkend="dir-tree-overview"/> zawiera wiêcej szczegó³ów;
    wyczerpuj±ce informacje znajduj± siê w: Linux Filesystem Standard.
	</para>

</sect2>

</sect1>

</chapter>


<chapter id="dir-tree-overview">
<title>Przegl±d struktury katalogów</title>

	<blockquote><para> <quote> Dwa dni pó¼niej  Pooh siedzia³ na swej ga³êzi i
    macha³ nó¿kami, obok niego sta³y cztery garnki pe³ne miodu...
	</quote> (A.A. Milne) </para></blockquote>

	<para> Rozdzia³ opisuje wa¿niejsze czê¶ci standardowej hierarchii
    katalogów, która oparta jest na standardzie FSSTND.
    Opisuje normalny sposób podzia³u na oddzielne systemy plików oraz
    cel takiego podzia³u. Ró¿ne alternatywy s± omówione.
	</para>

<sect1>
<title>Wstêp</title>

	<para> Rozdzia³ powsta³ na podstawie <citetitle>Standardu 
    Systemu Plików Linuxa</citetitle>, FSSTND, wersji 1.2 (zobacz
    bibliografiê).  Standaryzacja hierarchii katalogów ma na celu
    u³atwienie ¿ycia administratorom i programistom - ³atwiej co¶ znale¼æ
    je¿eli jest umieszczone w odpowiednim miejscu. U¿ywanie standardu
    nie jest przez nikogo wymagane, jednak wiêkszo¶æ dystrybucji tworzona
    jest zgodnie z nim. FSSTND definiuje podobn± hierarchiê jak w innych
    systemach Unix.
	</para>

	<para> Rozdzia³ nie zawiera szczegó³ów, po nie siêgnij do FSSTND.
	Administrator powinien rozumieæ i znaæ ten standard.
    </para>

	<para> Ca³e drzewo stworzone jest w sposób u³atwiaj±cy roz³o¿enie
    go na kilku dyskach, lub partycjach. G³ównymi czê¶ciami s±:
	katalog g³ówny, <filename>/usr</filename>, <filename>/var</filename>,
	<filename>/home</filename> (zobacz
	<xref linkend="fstree"/>).  Ka¿da z czê¶ci ma inne przeznaczenie.
	Niektóre z czê¶ci mog± znajdowaæ siê w sieci, na urz±dzeniach wy³±cznie
    odczytywalnych.
	</para>

		<figure id="fstree" float="1">
		<title>Czê¶ci drzewa katalogów Unixa. Linie oznaczaj± limity partycji.</title>
		<graphic fileref="fstree"></graphic>
		</figure>
	
	<para> Poni¿ej znajduje siê opis przeznaczenia danej czê¶ci.

	<itemizedlist>
	
		<listitem> <para> G³ówny system plików jest specyficzny dla ka¿dej
        z maszyn (generalnie znajduje siê na poszczególnych maszynach,
        choæ mo¿e byæ montowany z sieci, itd.), zawiera pliki
        niezbêdne do uruchomienia systemu i zamontowania innych
        systemów plików. Zawarto¶æ powinna byæ wystarczaj±ca do uruchomienia
        systemu w trybie jednego u¿ytkownika, naprawy pozosta³ych
        systemów plików oraz odtwarzania kopii zapasowych.
		</para> </listitem>

		<listitem><para>  <filename>/usr</filename> zawiera wszelkie
        polecenia, biblioteki, strony podrêcznika i inne niezmieniaj±ce
        siê dane potrzebne podczas normalnej pracy.
		Pliki w <filename>/usr</filename> nie powinny byæ zale¿ne od architektury
        komputera, nie powinny byæ zmieniane podczas pracy systemu.
		Umo¿liwia to dzielenie plików poprzez sieæ, co mo¿e byæ okazaæ 
        siê bardzo ekonomiczne - oszczêdza przestrzeñ dyskow± (katalog
        ten mo¿e zajmowaæ kilkaset megabajtów) i ³atwe do administracji
        (wystarczy uaktualniæ/zainstalowaæ program na jednym dysku)
		Nawet, je¿eli system plików znajduje siê na lokalnym dysku mo¿e
        byæ montowany wy³±cznie do odczytu - zmniejsza to szansê wyst±pienia
        b³êdów po padzie systemu.</para></listitem>

		<listitem> <para> Katalog <filename>/var</filename>
		zawiera pliki, które zmieniaj± siê, np. wszelkie kolejki
        (poczty, newsów, drukarek, etc. ), logi, sformatowane pliki
        podrêcznika oraz pliki tymczasowe. Tradycyjnie wszystko co
        znajduje siê w <filename>/var</filename> by³o umieszczane w
        <filename>/usr</filename>, jednak to uniemo¿liwia zamontowanie
        <filename>/usr</filename> wy³±cznie do odczytu.</para> </listitem>

		<listitem> <para>  System plików <filename>/home</filename>
		zawiera katalogi domowe u¿ytkowników - wszystkie ich dane.
        Odseparowanie danych u¿ytkownika u³atwia ich archiwizacjê;
        najczê¶ciej nie trzeba archiwizowaæ pozosta³ych danych, 
        lub mo¿na to robiæ rzadziej (nie s± tak czêsto zmieniane).
        Wielki <filename>/home</filename> mo¿e zostaæ podzielony na kilka
        dysków, mo¿liwe jest to przez dodanie poziomu po¶redniego, np.
        podzia³u <filename>/home/students</filename>, <filename>/home/staff</filename>;
        lub tworzenia katalogów zwi±zanych z pierwsz± liter± nazwy
        u¿ytkownika a dopiero w nim katalogu domowego.
		</para></listitem>

	</itemizedlist> </para>

	<para> Wszystkie te czê¶ci mog± znajdowaæ siê fizycznie na jednym systemie
    plików. Je¿eli jest to komputer domowy nie ma potrzeby stosowaæ
    takiego podzia³u, jednak w wiêkszych systemach unikniêcie go jest 
    niemo¿liwe. Wa¿ne jest aby wszystkie te <emphasis>nazwy</emphasis>
    dzia³a³y; np. powiedzmy, ¿e <filename>/var</filename> i
    <filename>/usr</filename> s± aktualnie na tej samej partycji,
	¶cie¿ka <filename>/usr/lib/libc.a</filename> i <filename>/var/log/messages</filename>
    musi dzia³aæ, w tym przyk³adzie mo¿naby przenie¶æ <filename>/var</filename>
    do <filename>/usr/var</filename> i utworzyæ odpowiednie ³±cze symboliczne -
	<filename>/var</filename> -> <filename>/usr/var</filename>.</para>

	<para> Hierarchia katalogów w Uniksie grupuje pliki odpowiednio do
    ich przeznaczenia - wszystkie polecenia s± w jednym miejscu,
    dane w innym, itd. Alternatywnie mo¿naby tworzyæ katalogi dla poszczególnych
    programów. Drugie podej¶cie ma kilka wad - trudno dzieliæ
    pliki (programy czêsto zawieraj± czê¶ci statyczne i wykonywalne),
    znalezienie programu mo¿e staæ siê trudne (np. zmuszenie
    programu man do zagl±dania w odpowiednich katalogach mo¿e staæ
    siê koszmarem).
    </para>

</sect1>

<sect1>
<title>G³ówny system plików</title>

	<para> Generalnie g³ówny system plików powinien byæ ma³y -
    zawiera krytyczne dane, a ma³y, rzadko zmieniany system ma wiêksze
    szanse przetrwania. Zniszczenie tego systemu plików najczê¶ciej
    oznacza, ¿e systemu nie mo¿na uruchomiæ - trzeba pos³u¿yæ
    siê dyskietk± lub innym dodatkowym medium.
	</para>

	<para> G³ówny katalog nie powinien zawieraæ ¿adnych plików, oprócz
    j±dra (chocia¿ powinno siê je umieszczaæ w /boot). 
	Wszelkie inne pliki powinny znajdowaæ siê w odpowiednich katalogach:
	<glosslist>

	<glossentry>
	<glossterm><filename>/bin</filename></glossterm>
		<glossdef><para> Polecenia potrzebne do uruchomienia systemu,
        pracy w trybie jednego u¿ytkownika.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/sbin</filename></glossterm>
		<glossdef><para> Podobnie jak <filename>/bin</filename>,
		przy czym polecenia te nie s± przeznaczone dla zwyk³ych u¿ytkowników.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/etc</filename></glossterm>
		<glossdef><para> Pliki konfiguracyjne specyficzne dla danego
        komputera.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/root</filename></glossterm>
		<glossdef><para> Katalog domowy u¿ytkownika root.
		</para></glossdef></glossentry>
		
	<glossentry>
	<glossterm><filename>/lib</filename></glossterm>
		<glossdef><para> Biblioteki dzielone wymagane przez programy znajduj±ce
        siê na g³ównym systemie plików.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/lib/modules</filename></glossterm>
		<glossdef><para> £adowalne modu³u j±dra, te wymagane do startu systemu i
        pracy po padzie systemu (sterowniki sieciowe, itd. )
		.</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/dev</filename></glossterm>
		<glossdef><para> Pliki urz±dzeñ.</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/tmp</filename></glossterm>
		<glossdef><para> Pliki tymczasowe. Programy dzia³aj±ce
        po starcie systemu powinny u¿ywaæ katalog <filename>/var/tmp</filename>, nie
        <filename>/tmp</filename>, poniewa¿ zapewne jest na nim wiêcej miejsca.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/boot</filename></glossterm>
		<glossdef><para> Pliki u¿ywane przez program bootuj±cy (np. LILO)
		Czêsto zawiera obraz j±dra. Powinien znajdowaæ siê poni¿ej
        1024 cylindra dysku IDE.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/mnt</filename></glossterm>
		<glossdef><para> Punkt tymczasowego montowania systemu plików.
        Nie powinno siê montowaæ ¿adnego systemu plików automatycznie w
        tym katalogu.
		<filename>/mnt</filename> mo¿e zawieraæ podkatalogi
        (np.: <filename>/mnt/dosa</filename> mo¿e oznaczaæ dyskietkê DOS-a,
		<filename>/mnt/exta</filename> dyskietkê z systemem plików 
		ext2).</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/proc</filename>, <filename>/usr</filename>, <filename>/var</filename>, <filename>/home</filename></glossterm>
		<glossdef><para> Punkty montowañ innych systemów plików.
		</para></glossdef></glossentry>

	</glosslist>
	</para>

</sect1>

<sect1>
<title>Katalog <filename>/etc</filename></title>

	<para> Katalog <filename>/etc</filename> zawiera mnóstwo plików.
	Niektóre z nich s± opisane poni¿ej. Odno¶nie innych - powiniene¶
    sprawdziæ jaki program u¿ywa danego pliku, po czym przeczytaæ dokumentacjê
    od danego programu, istniej± równie¿ strony dotycz±ce plików (sekcja 5).
	Wiele plików konfiguruj±cych sieæ znajduje siê w 
	<filename>/etc</filename>, s± one opisane w <citetitle>Networking Administrators' Guide</citetitle>.

	<glosslist>
	
	<glossentry>
	<glossterm><filename>/etc/rc</filename>, lub <filename>/etc/rc.d</filename>, lub <filename>/etc/rc?.d</filename></glossterm>
		<glossdef><para> Skrypty, lub katalogi zawieraj±ce skrypty
        uruchamiane podczas startu systemu i zmiany poziomu pracy.
		Zobacz sekcjê dotycz±c± programu <command>init</command>
		.</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/etc/passwd</filename></glossterm>
		<glossdef><para> Baza u¿ytkowników zawieraj±ca: nazwê, prawdziw± nazwê, katalog domowy, zakodowane has³o i inne informacje dla ka¿dego z u¿ytkowników systemu.
Dok³adniejszy opis znajduje siê na stronie podrêcznika dotycz±cej <command>passwd</command>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/fdprm</filename></glossterm>
		<glossdef><para> Tabela parametrów pracy stacji dyskietek.
		Opisuje wzory poszczególnych formatów dyskietek.
        U¿ywana przez <command>setfdprm</command>.  Zobacz podrêcznik dla
        <command>setfdprm</command>.  </para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/fstab</filename></glossterm>
		<glossdef><para> Lista systemów plików montowanych automatycznie
        za pomoc± <command>mount -a</command> 
        (wywo³ywanego w <filename>/etc/rc</filename> lub inny skrypt startowy
		).  Pod Linuxem zawiera informacje o swapie u¿ywanym automatycznie
        po poleceniu <command>swapon -a</command>. 
        Zobacz <xref linkend="mount-and-umount"/>, oraz stronê podrêcznika
        polecenia <command>mount</command>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/group</filename></glossterm>
		<glossdef><para> Plik podobny do
		<filename>/etc/passwd</filename>, zawiera opis grup.
		Zobacz stronê podrêcznika dotycz±c±
		<command>group</command>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/inittab</filename></glossterm>
		<glossdef><para> Plik konfiguruj±cy pracê programu
		<command>init</command>.  </para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/issue</filename></glossterm>
		<glossdef><para> Wy¶wietlany przez <command>getty</command> 
        przed pytaniem o login. Zazwyczaj zawiera krótk± informacjê,
        lub powitanie. Zawarto¶æ zale¿y od upodobañ administratora.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/magic</filename></glossterm>
		<glossdef><para> Plik konfiguracyjny dla programu
		<command>file</command>.  Zawiera opisy ró¿nych formatów plików,
        na podstawie których <command>file</command> zgaduje typ pliku.
		Zobacz strony podrêcznika dotycz±ce: <filename>magic</filename> i
		<command>file</command>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/motd</filename></glossterm>
		<glossdef><para> Wiadomo¶æ dnia, automatycznie wy¶wietlana po
        udany logowaniu. Zawarto¶æ zale¿y od upodobañ administratora.
        Czêsto u¿ywany aby przekazaæ wiadomo¶æ wszystkim u¿ytkownikom.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/mtab</filename></glossterm>
		<glossdef><para> Lista aktualnie zamontowanych systemów plików.
        Inicjowana przez skrypty startowe i uaktualniana automatycznie przez 
		program <command>mount</command>.
		U¿ywana gdy potrzeba listy aktualnie zamontowanych systemów plików.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/shadow</filename></glossterm>
		<glossdef><para> Plik hase³ na niektórych systemach -
		czêsto has³a s± przeniesione z pliku 
		<filename>/etc/passwd</filename> do 
		<filename>/etc/shadow</filename>; drugi plik, odmiennie od pierwszego,
        jest odczytywalny tylko przez roota. Utrudnia to próbê brutalnego
        ³amania hase³.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/login.defs</filename></glossterm>
		<glossdef><para> Plik konfiguracyjny programu
		<command>login</command>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/printcap</filename></glossterm>
		<glossdef><para> Podobny do <filename>/etc/termcap</filename>,
zawiera informacje na temat drukarek. Odmienna sk³adnia.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/profile</filename>, <filename>/etc/csh.login</filename>, <filename>/etc/csh.cshrc</filename></glossterm>
		<glossdef><para> pliki wykonywane w czasie ³adowania odpowiednio:
        pow³oki Bourne'a i C. Dziêki nim administrator mo¿e tworzyæ
        domy¶lne, globalne ustawienia dla wszystkich u¿ytkowników.
		Zobacz stronê podrêcznika odpowiedniej pow³oki.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/securetty</filename></glossterm>
		<glossdef><para> Zawiera listê bezpiecznych terminali - 
        terminali, przez które mo¿e siê zalogowaæ root.
		Najczê¶ciej zawiera listê kilku wirtualnych terminali, utrudniaj±c
        zdobycie praw roota przez sieæ, lub terminal na porcie szeregowym.
        Najlepiej usun±æ wszystkie wpisy - uniemo¿liwia to bezpo¶rednie
        zalogowanie siê roota w trybie wielu u¿ytkowników - nale¿y
        zalogowaæ siê jako zwyk³y u¿ytkownik, a pó¼niej u¿yæ polecenia
        su.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/shells</filename></glossterm>
		<glossdef><para> Lista zaufanych pow³ok. Polecenie
		<command>chsh</command> umo¿liwia u¿ytkownikom
        zmianê pow³oki logowania wy³±cznie na jedn± z zawartych w pliku.
		Niektóre demony <command>FTP</command> uniemo¿liwiaj± zalogowanie siê
        u¿ytkownika, który nie posiada prawid³owej pow³oki.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/etc/termcap</filename></glossterm>
		<glossdef><para> Baza mo¿liwo¶ci terminala.
		Opisuje sekwencje escape'owe, którymi mo¿na kontrolowaæ
        terminal. Programy nie wy¶wietlaj± znaków bezpo¶rednio 
        (trzebaby by³o wbudowaæ im ca³± bazê danych, lub
        u¿ywaæ odpowiedniego terminala), w zamian tego pos³uguj± siê
        podanymi w tym pliku sekwencjami sterowania, dziêki temu
        mog± pracowaæ na dowolnym terminalu a dodanie nowego jest
        proste. Zobacz strony podrêcznika:
		<filename>termcap</filename>, curs_termcap,
		<filename>terminfo</filename>.
		</para></glossdef></glossentry>

	</glosslist>
	</para>

</sect1>

<sect1>
<title>Katalog <filename>/dev</filename></title>

	<para> Katalog <filename>/dev</filename> zawiera pliki specjalne, które
    odpowiadaj± wszystkim urz±dzeniom. Nazwy plików tworzone s± wed³ug specjalnej
    konwencji; opisana jest ona w dokumencie <citetitle>Device list</citetitle> (zobacz
	XXX).  Pliki urz±dzeñ tworzone s± podczas instalacji,
    pó¿niej mo¿na je utworzyæ za pomoc± 
	<command>/dev/MAKEDEV</command>, lub programu <command>mknod</command>.
	Skrypt <command>/dev/MAKEDEV.local</command> jest tworzony przez
    administratora w celu utworzenia urz±dzeñ u¿ywanych lokalnie.
	(tych, które nie zawartych w skrypcie
	<command>MAKEDEV</command>, np. dla niestandardowych urz±dzeñ). 
	</para>

</sect1>

<sect1>
<title>System plików <filename>/usr</filename></title>

	<para> System plików <filename>/usr</filename> jest zazwyczaj
    du¿y - wiêkszo¶æ programów znajduje siê w jego podkatalogach.
	Zazwyczaj wszystkie pliki w katalogu
	<filename>/usr</filename> przysz³y wraz z dan± dystrybucj±,
    programy instalowane rêcznie, z innych pakietów powinny byæ
    umieszczane w <filename>/usr/local</filename>.	Dziêki
    temu po aktualizacji, zmianie systemu nie musimy instalowaæ (a przed tym
    np. ¶ci±gaæ z sieci) dodatkowych programów.
	Niektóre z podkatalogów <filename>/usr</filename> opisane s± poni¿ej
    (pe³ny opis i lista znajduj± siê w FSSTND).
	<glosslist>
	
	<glossentry>
	<glossterm><filename>/usr/X11R6</filename></glossterm>
		<glossdef><para> X Window System, wszystkie pliki.
		Aby upro¶ciæ tworzenie i instalacjê systemu X, wszelkie pliki
        umieszczane s± w osobnym katalogu.
		W <filename>/usr/X11R6</filename> istnieje hierarchia podkatalogów
        podobna do zawarto¶ci <filename>/usr</filename>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/usr/X386</filename></glossterm>
		<glossdef><para> To samo co
		<filename>/usr/X11R6</filename>, tylko dla wersji "X11 Release 5".
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/usr/bin</filename></glossterm>
		<glossdef><para> Prawie wszystkie polecenia u¿ytkownika.
		Niektóre polecenia znajduj± siê w <filename>/bin</filename> i
        <filename>/usr/local/bin</filename>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/usr/sbin</filename></glossterm>
		<glossdef><para> Programy administratora, które nie musz±
        znajdowaæ siê na g³ównym systemie plików, np. wiêkszo¶æ
        serwerów.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/usr/man</filename>, <filename>/usr/info</filename>, <filename>/usr/doc</filename></glossterm>
		<glossdef><para> Odpowiednio: strony podrêcznika, dokumenty GNU Info i dokumentacja
        w innych formatach.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/usr/include</filename></glossterm>
		<glossdef><para> Pliki nag³owkowe dla jêzyka C.
		Aktualnie powinny byæ w 
		<filename>/usr/lib</filename>, jednak tradycja jest silniejsza.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/usr/lib</filename></glossterm>
		<glossdef><para> Niezmieniaj±ce siê dane, zale¿ne od architektury,
        niekiedy pliki konfiguracyjne programów.
		Nazwa <filename>lib</filename> pochodzi od "library" (biblioteka);
		oryginalnie biblioteki programistyczne by³y przechowywane w 
		<filename>/usr/lib</filename>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/usr/local</filename></glossterm>
		<glossdef><para> Miejsce sk³adowania oprogramowania (i konfiguracji)
        zainstalowanego niezale¿nie od dystrybucji.
		</para></glossdef></glossentry>

	</glosslist></para>

</sect1>

<sect1>
<title>System plików <filename>/var</filename></title>

	<para> <filename>/var</filename> zawiera zmieniaj±ce siê dane.
	Zawarto¶æ jest specyficzna dla danego systemu, nie powinna byæ
    dzielona miêdzy ró¿nymi komputerami.

	<glosslist>
	
	<glossentry>
	<glossterm><filename>/var/catman</filename></glossterm>
		<glossdef><para> Sformatowane strony.
		¬ród³o strony podrêcznika jest zazwyczaj przechowywane
        w <filename>/usr/man/man*</filename>; niektóre strony
        rozprowadzane s± w wersji preformatowanej,
		s± one przechowywane w <filename>/usr/man/cat*</filename>.
		Inne strony podrêcznika musz± zostaæ sformatowane przed
        wy¶wietleniem; przetworzone wersje, w celu przy¶pieszenia
        pó¼niejszych odwo³añ, zapisywane s± na dysku.
		(<filename>/var/catman</filename> jest czêsto czyszczony wraz
        z katalogami zawieraj±cymi pliki tymczasowe.)
        </para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/var/lib</filename></glossterm>
		<glossdef><para> Zmieniaj±ce siê podczas pracy systemu pliki.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/var/local</filename></glossterm>
		<glossdef><para> Zmieniaj±ce siê dane programów zainstalowanych
        w <filename>/usr/local</filename>. Zauwa¿, ¿e nawet lokalnie
        zainstalowane programy powinny siê odwo³ywaæ do
		<filename>/var</filename>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/var/lock</filename></glossterm>
		<glossdef><para> Blokady. Wiele programów przestrzega zasadê
        tworzenia pliku w
		<filename>/var/lock</filename> aby wskazaæ swoje dzia³anie.
		Inne programy sprawdzaj± plik i odpowiednio dzia³aj± (np.
        wstrzymuj± siê z odwo³ywaniem do danego urz±dzenia).
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/var/log</filename></glossterm>
		<glossdef><para> Logi ró¿nych programów, baza programu
		<command>login</command>
		(<filename>/var/log/wtmp</filename>, który zawiera informacje
        o wylogowywaniu siê u¿ytkowników) oraz log demona <command>syslog</command>
		(<filename>/var/log/messages</filename>, w nim zapisywane s±
        wszystkie informacje j±dra i innych programów).
		Zapomniane pliki w <filename>/var/log</filename> mog± czêsto
        znacz±co przybraæ na rozmiarze - powiniene¶ w regularnych
        odstêpach czasu usuwaæ stare wersje.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/var/run</filename></glossterm>
		<glossdef><para> Pliki, które zawieraj± informacje
        o systemie, które s± aktualne podczas jego dzia³ania.
		Dla przyk³adu: <filename>/var/run/utmp</filename> zawiera
        listê u¿ytkowników aktualnie zalogowanych.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/var/spool</filename></glossterm>
		<glossdef><para> Katalog zawieraj±cy kolejki: poczty,
        drukowania i inne.
		Ka¿da kolejka posiada w³asny podkatalog wewn±trz
		<filename>/var/spool</filename>, np. czêsto poczta przechowywana jest
        w katalogu <filename>/var/spool/mail</filename> (nie jest to zalecane).
        </para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/var/tmp</filename></glossterm>
		<glossdef><para> Tymczasowe pliki które s± du¿e, lub maj± istnieæ
        przez d³u¿szy czas ni¿ by³oby to mo¿liwe w katalogu
		<filename>/tmp</filename>
		(aczkolwiek administrator mo¿e usuwaæ znacz±co stare pliki).
		</para></glossdef></glossentry>

	</glosslist></para>

</sect1>

<sect1>
<title>System plików <filename>/proc</filename></title>

	<para>  System plików <filename>/proc</filename> jest ca³kowicie
    wirtualny - nie istnieje na dysku.
	Jest tworzony i utrzymywany przez j±dro w pamiêci. U¿ywany
    jest w celu dostarczenia informacji o systemie (oryginalnie o
    dzia³aj±cych procesach, st±d nazwa). Wa¿niejsze pozycje omówione
    s± poni¿ej.
	System plików <filename>/proc</filename> posiada w³asn± stronê
    podrêcznika.
	<glosslist>
	
	<glossentry>
	<glossterm><filename>/proc/1</filename></glossterm>
		<glossdef><para> Katalog zawieraj±cy informacje o procesie
        numer 1 (init ma zawsze ten numer). Ka¿dy proces posiada
        w³asny podkatalog o nazwie przedstawiaj±cej identyfikator
        procesu.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm><filename>/proc/cpuinfo</filename></glossterm>
		<glossdef><para> Informacje o procesorze: model, wydajno¶æ, itp.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/devices</filename></glossterm>
		<glossdef><para> Lista sterowników urz±dzeñ, które s± aktualnie 
        skonfigurowane i dzia³aj±ce.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/dma</filename></glossterm>
		<glossdef><para> Aktualnie u¿ywane kana³y DMA.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/filesystems</filename></glossterm>
		<glossdef><para> Systemy plików aktualnie skonfigurowane.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/interrupts</filename></glossterm>
		<glossdef><para> Lista przerwañ aktualnie wykorzystywanych,
        oraz ilo¶æ przerwañ, które zosta³y kiedykolwiek obs³u¿one.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/ioports</filename></glossterm>
		<glossdef><para> U¿ywane porty We/Wy.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/kcore</filename></glossterm>
		<glossdef><para> Obraz fizycznej pamiêci systemu.
        Posiada rozmiar równy rozmiarowi zainstalowanej pamiêci, jednak
        na dysku nie zajmuje ani bajta.
		(Uwaga: wpisy w katalogu 
		<filename>/proc</filename> nie zajmuj± miejsca, chyba ¿e je skopiujesz
        w inne miejsce).
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/kmsg</filename></glossterm>
		<glossdef><para> Wiadomo¶ci wysy³ane przez j±dro.
		S± one równie¿ przesy³ane do <command>sysloga</command>.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/ksyms</filename></glossterm>
		<glossdef><para> Tablica symboli j±dra.
		</para></glossdef></glossentry>	
	
	<glossentry>
	<glossterm><filename>/proc/loadavg</filename></glossterm>
		<glossdef><para> `¶rednie obci±¿enie' systemu; trzy nic
        nie znacz±ce liczby wskazuj±ce ilo¶æ aktualnie wykonywanej
        pracy.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/meminfo</filename></glossterm>
		<glossdef><para> Informacje o wykorzystaniu pamiêci fizycznej i swapu.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/modules</filename></glossterm>
		<glossdef><para> Aktualnie za³adowane modu³y.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/net</filename></glossterm>
		<glossdef><para> Informacje o protoko³ach sieciowych.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/self</filename></glossterm>
		<glossdef><para> £±cze symboliczne do katalogu procesu,
        który czyta <filename>/proc</filename>.  Dla dwóch procesów
        czytaj±cych <filename>/proc</filename> wskazania odno¶ników s±
        inne.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/stat</filename></glossterm>
		<glossdef><para> Statystyki systemu, np. ilo¶æ b³êdów
        stron od czasu startu, itd.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/uptime</filename></glossterm>
		<glossdef><para> Okres pracy systemu.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><filename>/proc/version</filename></glossterm>
		<glossdef><para> Wersja j±dra.
		</para></glossdef></glossentry>
	
	</glosslist></para>

	<para> Zauwa¿, ¿e wiêkszo¶æ z tych plików jest w postaci
    textowej, mog± one byæ czasami w postaci niezbyt czytelnej.
	Istnieje wiele poleceñ, które odczytuj± takie pliki i specjalnie
    je przetwarzaj±. Np. program
	<command>free</command> rozumie plik <filename>/proc/meminfo</filename>
    i konwertuje warto¶ci podane w bajtach na kB oraz dodaje inne
    informacje.
	</para>
	
</sect1>

</chapter>

<chapter>
<title>Korzystanie z ró¿nych medii przechowuj±cych dane</title>

	<blockquote><para> <quote>Czysty dysk mo¿esz przeszukiwaæ wiecznie.
	</quote></para></blockquote>

<!--
% the following metas need too much work for the next version
%
%	\meta copying a directory/disk verbatim
%
%	\meta disaster recovery: program to scan for ext2 superblocks
%
%	\meta explain lost+found; how to fix a filesystem; what to do when
%	there is a bad block; identifying the file that has the bad block
%	
%	\meta chart that shows characteristics of various fs: max size,
%	max file size, usable as root, max name length, speed, support
%
%	\meta 
%	Recovering from a bad MBR or super block.
%	Manually remounting (ro->rw, rw->ro, when, why)
%	automounting
%	MD patches
%	Why does Linux read/write disk in background?
%	how to mount a dos disk so that everyone can access it?
%	supermount
%	ide disks map away bad sectors (until they're too many, then
%	use badblocks)
%	mounting: mountee root becomes mount point, e.g. permissions/ownership
%	linux has maximum of 15 partitions (not inherent in partition
%		scheme!)
%	max ext2 part size is 2TB, file 2 GB
%	ext2 fragmentation
%	list important device files for disks et al as a table
-->

        <para> Instaluj±c lub uaktualniaj±c system musisz dokonaæ wiele
        operacji dyskowych. Musisz stworzyæ systemy plików, zarezerwowaæ
        odpowiedni± ilo¶æ miejsca dla poszczególnych czê¶ci.
        </para>

        <para> Rozdzia³ omawia wszystkie te czynno¶ci. Zazwyczaj
        etap ten jest jednokrotny, za wyj±tkiem pracy z dyskietkami.
        Bêdziesz musia³ powróciæ do tego rozdzia³u w przypadku nowego
        dysku lub optymalizacji operacji dyskowych.
        </para> 

    <para> Podstawowe obowi±zki:</para>
	<itemizedlist>
	<listitem><para> 
        Sformatowaæ dysk. Oznacza to wszelkie rzeczy przygotowuj±ce
        dysk do pracy, sprawdzenie wystêpowania z³ych sektorów
        (aktualnie formatowanie nie jest konieczne).
	    </para></listitem>

	<listitem><para> 
        Stworzyæ partycje. Mo¿e to byæ nieuniknione w przypadku chêci
        posiadania kilku odmiennych systemów operacyjnych.
        Rozmieszczenie drzewa katalogów na kilku dyskach czyni czê¶æ
        z nich bardziej odpornymi na b³êdy - niektóre z nich mo¿na
        zamontowaæ jako wy³±cznie do odczytu, czêsto plików u¿ytkowników
        umieszcza siê na innej partycji w celu uproszczenia
        tworzenia kopii zapasowych.
	</para></listitem>

	<listitem><para> 
        Stworzyæ system plików (odpowiedniego typu) na ka¿dej partycji.
	    Linux nie mo¿e dzia³aæ bez systemu plików - tylko w oparciu
        o niego mo¿na tworzyæ/kasowaæ pliki, itd.
	</para></listitem>

	<listitem><para> 
        Zamontowaæ ró¿ne systemu plików w odpowiedniej hierarchi -
        automatczynie lub rêcznie (rêcznie montowane systemy plików
        s± zazwyczaj odmontowywane, ale powiniene¶ siê upewniæ).
	</para></listitem>

	</itemizedlist>

	<para> <xref linkend="memory-management"/> zawiera informacje
    o wirtualnej pamiêci i buforowaniu operacji dyskowych - o czym
    powiniene¶ pomy¶leæ.
	</para>

<sect1>
<title>Dwa typy urz±dzeñ</title>

	<para> UNIX, oraz Linux, rozpoznaje dwa typy urz±dzeñ: 
    urz±dzenia blokowe losowego dostêpu (dyski), oraz urz±dzenia
    znakowe (ta¶my, po³±czenia szeregowe ), niektóre z nich mo¿na
    odczytywaæ losowo, niektóre sekwencyjnie. Ka¿de z urz±dzeñ
    posiada <glossterm>plik urz±dzenia</glossterm>. Czytaj±/zapisuj±c
    do pliku urz±dzenia odwo³ujesz siê do przypisanego plikowi sprzêtu.
    Dziêki temu nie potrzeba ¿adnych specjalnych programów (oraz
    specjalnego stylu programowania) aby u¿ywaæ dane urz±dzenie.
    Dla przyk³adu: aby wys³aæ plik na drukarkê wystarczy

<screen>
<prompt>$</prompt> <userinput>cat filename &gt; /dev/lp1</userinput>
<prompt>$</prompt>
</screen>

	i zawarto¶æ pliku zostanie wydrukowana (oczywi¶cie plik musi
    byæ w formacie akceptowanym przez drukarkê). Jednocze¶nie, je¿eli
    kilku u¿ytkowników wy¶le jednocze¶nie pliki na drukarkê mo¿e
    powstaæ sieczka - aby temu zapobiec nale¿y skorzystaæ z zewnêtrznych
    programów (np. <command>lpr</command>). Program ten upewnia siê, ¿e
    tylko jeden plik jest w danym momencie drukowany. Takie podej¶cie
    wymagane jest dla wielu urz±dzeñ. Zasadniczo, nie powiniene¶
    zajmowaæ siê plikami urz±dzeñ, ale odpowiednimi programami.
	</para>

	<para> Poniewa¿ urz±dzenia s± plikami (w katalogu <filename>/dev</filename> directory)
	mo¿na siê ³atwo przekonaæ czy dane urz±dzenie istnieje - wystarczy
    u¿yæ <command>ls</command>, lub podobnego programu.
    Polecenie <command>ls -l</command> pokazuje w pierwszej kolumnie
    typ urz±dzenia, w drugiej prawa dostêpu. Dla przyk³adu:

<screen>
<prompt>$</prompt> <userinput>ls -l /dev/cua0</userinput>
<computeroutput>crw-rw-rw-   1 root     uucp       5,  64 Nov 30  1993 /dev/cua0</computeroutput>
<prompt>$</prompt>
</screen>

	Pierwszy znak w <literal>crw-rw-rw-</literal> - 
    `<literal>c</literal>' oznacza, ¿e jest to urz±dzenie znakowe.
    Dla zwyk³ych plików pierwszym znakiem jest 
	`<literal>-</literal>', dla katalogów
	`<literal>d</literal>', dla urz±dzeñ blokowych
	`<literal>b</literal>'; zobacz stronê podrêcznika o programie <command>ls</command>.
    </para>

	<para> Zapamiêtaj, ¿e wiêkszo¶æ plików istnieje pomimo braku 
    zainstalowanych urz±dzeñ. Takie podej¶cie upraszcza proces instalacji,
    oraz dodawania nowego sprzêtu (nie trzeba znaæ odpowiednich programów
    i ich opcji aby utworzyæ odpowiedni plik).
	</para>

</sect1>

<sect1>
<title>Dyski twarde</title>

	<para> Sekcja wprowadza terminologiê zwi±zan± z dyskami twardymi.
	Je¿eli znasz te terminy mo¿esz opu¶ciæ j±.
	</para>

	<para> Zobacz <xref linkend="hd-schematic"/> aby poznaæ schematyczny
    obraz najwa¿niejszych czê¶ci dysku twardego. Dysk sk³ada siê
    z jednego lub kilku cylindrycznych talerzy,
	
		<footnote><para> Talerze wykonane s± z twardej substancji - np.
        aluminium, st±d pochodzi nazwa.
		</para></footnote>
		
	których jedna lub obie <glossterm>powierzchnie</glossterm> posiadaj±
    naniesion± substancjê czynn± magnetycznie. Dla ka¿dej powierzchni
    istnieje <glossterm>g³owica zapisuj±co-czytaj±ca</glossterm>.
    Talerze maj± wspóln± o¶ obrotu, standardowo obracaj± siê ~5000 razy
    w ci±gu minuty (mo¿na zakupiæ dyski z 10000 RPM - rotacjami na minutê).
	G³owice poruszaj± siê nad powierzchni± talerzy, wzd³u¿ promienia - dziêki
    ruchom g³owic i rotacji talerzy mo¿na otrzymaæ dostêp do ka¿dego obszaru
    powierzchni.
	</para>

	<para> Procesor (CPU) i dysk komunikuj± siê poprzez
	<glossterm>kontroler dysku</glossterm>. Tylko ta czê¶æ musi
    wiedzieæ w jaki sposób komunikowaæ siê z dyskiem twardym, do tego
    kontrolery maj± wspólny interfejs programowy umo¿liwiaj±c prosty
    dostêp do dysku - komputer mówi "dawaj czego chcê", zamiast wykonywaæ
    serii skomplikowanych przetworzeñ sygna³ów elektrycznych (w gruncie
    rzeczy komunikacja z kontrolerem jest równie¿ skomplikowana, ale
    takie podej¶cie znacz±co u³atwia wspó³pracê komputer-dysk).
    Wiêkszo¶æ nowoczesnych kontrolerów nie poprzestaje na tym -
    czê¶æ z nich buforuje dane, zastêpuje z³e sektory, itd.
	</para>

	<para> Zazwyczaj powy¿sze informacje wystarczaj± '¶miertelnikowi',
    jednak istnieje kilka innych elementów: silnik poruszaj±cy talerzami,
    mechanizm pozycjonowania g³owic, elektronika dysku, których nie trzeba
    znaæ aby zrozumieæ dzia³anie dysku twardego.
	</para>

	<para> Zazwyczaj talerze podzielone s± na koncentryczne pier¶cienie
    nazywane <glossterm>¶cie¿kami</glossterm>, te z kolei podzielone s±
    na <glossterm>sektory</glossterm>. Podzia³ ten s³u¿y do okre¶lania
    po³o¿enia danych oraz allokowania miejsca dla plików.
    Aby znale¼æ odpowiednie miejsce mo¿na wskazaæ:
    "powierzchnia 3, ¶cie¿ka 5, sektor 7". Zazwyczaj liczba sektorów
    jest sta³a dla ka¿dej ze ¶cie¿ek, jednak zdarza siê, ¿e na
    zewnêtrznych ¶cie¿ka znajduje siê wiêcej sektorów (wszystkie
    sektory s± takiego samego rozmiaru). Zazwyczaj sektor ma 512 bajtów,
    nie istnieje mo¿liwo¶æ zapisu na dysku mniejszej porcji danych.
	</para>

		<figure id="hd-schematic" float="1">
		<title>Schematyczny obraz dysku twardego.</title>
		<graphic fileref="hd-schematic"></graphic>
		</figure>

	<para> Ka¿da powierzchnia podzielona w ten sam sposób na ¶cie¿ki
    i sektory. Oznacza to, ¿e gdy g³owica znajduje siê na danej
    ¶cie¿ce inne g³owice równie¿ s± na odpowiadaj±cych jej ¶cie¿kach.
    Wszystkie odpowiadaj±ce sobie ¶cie¿ki nazywane s±
	<glossterm>cylindrem</glossterm>. Przesuwanie g³owic jest czasoch³onne
    (na inn± ¶cie¿kê) - umieszczanie danych na jednym cylindrze jest
    optymalnym rozwi±zaniem. Jednak¿e nie jest to zawsze mo¿liwe -
    czasami plik trzeba roz³o¿yæ w kilku ró¿nych miejscach, mówi siê
    wtedy, ¿e dosz³o do
	<glossterm>fragmentacji</glossterm> pliku.</para>

	<para> Liczba powierzchni (lub g³owic, co jest tym samym),
    cylindrów i sektorów zmienia siê z ka¿dym dyskiem;
    warto¶ci okre¶laj±ce te liczby nazywa siê 
    <glossterm>geometri±</glossterm> dysku twardego. Geometria przechowywana
    jest zazwyczaj w zasilanej bateryjnie pamiêci zwanej
	<glossterm>CMOS RAM</glossterm>, stamt±d odczytuje j± system operacyjny.
	</para>

	<para> Niestety BIOS
	
		<footnote><para> BIOS (Basic Input/Output System - system podstawowego we/wy)
        jest wbudowanym oprogramowaniem przechowywanym w pamiêci ROM
        p³yty g³ównej. Zajmuje siê m.in. pocz±tkow± faz± uruchamiania 
        komputera.
		</para></footnote>
		
	posiada ograniczenia, które uniemo¿liwiaj± wprowadzenie liczby ¶cie¿ek
    wiêkszej od 1024 do CMOS RAM, dla dzisiejszych dysków jest to za ma³o.
    Aby to obej¶æ kontroler dysku twardego podaje nieprawdziwe
    informacje o geometrii dysku, po czym <glossterm>t³umaczy adresy</glossterm>
    podane przez komputer do postaci rzeczywistej. 
    Dla przyk³adu powiedzmy, ¿e mamy dysk posiadaj±cy 8 g³owic,
    2048 ¶cie¿ek i 35 sektorów w danej ¶cie¿ce.
	
		<footnote><para> S± to zmy¶lone liczby.
		</para></footnote>
		
	Kontroler móg³by podaæ, ¿e dysk posiada 16 g³owic, 1024 ¶cie¿ek i 35
    sektorów na ¶cie¿ce, dziêki temu limit nie zostaje przekroczony,
    natomiast kontroler ma trochê wiêcej roboty. W rzeczywisto¶ci
    matematyka mo¿e byæ bardziej zagmatwana, jednak rzeczywiste warto¶ci
    nie s± nam potrzebne, tworzenie jednego cylindra, itp. s± niepraktyczne,
    nie przynosz± one ¿adnego wzrostu wydajno¶ci.
	</para>

	<para> T³umaczenie wymagane jest w przypadków dysków IDE. Dyski
    SCSI u¿ywaj± sekwencyjnych numerów sektorów (kontroler t³umaczy
    poszczególne liczby: g³owica, cylinder, sektor), do tego
    u¿ywa siê odmiennego sposobu komunikacji miêdzy CPU a kontrolerem -
    problem nie istnieje. Zauwa¿, ¿e komputer czêsto nie zna
    prawdziwej geometrii dysku, nie jest mu ona potrzebna.
	</para>

	<para> Poniewa¿ Linux czêsto nie zna prawdziwej geometrii 
    dysku nie stara siê tworzyæ plików na jednym cylindrze.
    Zamiennie stara siê przydzielaæ plikom sekwencyjne numery
    sektorów, co zazwyczaj daje podobn± prêdko¶æ.
    Sprawa jest komplikowana przez bufory kontrolera, automatyczne
    przewidywanie akcji, itd.
	</para>

	<para> Ka¿dy dysk twardy reprezentowany jest przez pojedynczy
    plik urz±dzenia. Pliki takie mog± nazywaæ siê 
	<filename>/dev/hda</filename>, <filename>/dev/hdb</filename>, <filename>/dev/hdc</filename>,
	i <filename>/dev/hdd</filename>dla IDE. Dyski SCSI
	znane jest pod nazw± <filename>/dev/sda</filename>,
	<filename>/dev/sdb</filename>, itd. Podobne konwencje nazewnictwa
    obowi±zuj± inne dyski twarde; zobacz listê urz±dzeñ.
	Zapamiêtaj, ¿e plik dysku odnosi siê do ca³ej zawarto¶ci - nie obowi±zuje
    podzia³ na partycje, itd., urz±dzenie takie u¿ywane jest najczê¶ciej
    w czasie modyfikacji MBR.
	</para>

</sect1>

<sect1>
<title>Dyskietki</title>

	<para> Dyskietka sk³ada siê z elastycznej membrany pokrytej
    z jednej lub obu stron materia³em magnetycznie aktywnym.
    Dyskietka nie zawiera ¿adnych mechanizmów - wszystko to znajduje siê
    w odpowiednim napêdzie. Dyskietka odpowiada jednemu talerzowi dysku,
    twardego, przy czym jest wymienna - jeden napêd mo¿e odczytywaæ kilka
    dyskietek po kolei, dysk twardy jest niepodzielny.
    </para>

	<para> Tak jak dysk twardy dyskietka podzielona jest na ¶cie¿ki, sektory
    (dwie odpowiadaj±ce sobie ¶cie¿ki po dwóch stronach tworz± cylinder),
    przy czym jest ich znacznie mniej ni¿ na dysku twardym.
	</para>

	<para> Napêd dyskietek mo¿e odczytywaæ kilka ró¿nych formatów; dla 
    przyk³adu: istniej± 3,5 calowe dyskietki 720 kB i 1,44 MB.
	Do prawid³owego obs³u¿enia napêdu system operacyjny musi znaæ
    rozmiar dyskietki; istnieje kilka plików dyskietek:
	<filename>/dev/fd0H1440</filename> jest pierwszym napêdem zawieraj±cym
    3,5 calow±, podwójn± (D) dyskietkê o wysokiej gêsto¶ci (H), o pojemno¶ci
    1440 kB, innymi s³owy normalna dyskietka 3.5 calowa HD.
	Aby dowiedzieæ siê wiêcej o nazewnictwie zajrzyj do listy urz±dzeñ.
	</para>

	<para> Nazewnictwo napêdu dyskietek jest skomplikowane, jednak
    istnieje w Linuksie specjalne urz±dzenie wykrywaj±ce
    typ dyskietki. Dzia³a na zasadzie odczytu pierwszego sektora
    i wyszukiwania pasuj±cego wzorca. Wymaga to preformatowanie
    dyskietki.
	Urz±dzenia takie nazywaj± siê: <filename>/dev/fd0</filename>,
	<filename>/dev/fd1</filename>, itd.</para>

	<para> Parametry u¿ywane do sprawdzenia formatu dyskietki mog±
    zostaæ ustawione za pomoc± <command>setfdprm</command>.  
    Dziêki temu programowi mo¿na u¿ywaæ dyskietek o niestandardowym
    rozmiarze (mo¿na sobie tworzyæ takie dyskietki :-).
	</para>

	<para> Linux mo¿e odczytywaæ niestandardowe formaty dyskietek,
    niektóre z nich wymagaj± specjalnych programów formatuj±cych.
    Ominiemy je na razie, aby¶ w miêdzyczasie zd±¿y³ zajrzeæ do
    pliku <filename>/etc/fdprm</filename>, który to zawiera
    ustawienia programu <command>setfdprm</command>.</para>

	<para> System operacyjny musi wiedzieæ czy dyskietka zosta³a 
    zmieniona, np. aby unikn±æ u¿ywania zbuforowanych danych w przypadku
    zamiany dyskietek. Niestety linia sygna³u, która jest do 
    tego u¿ywana, w niektórych napêdach jest zepsuta - nie 
    mo¿na tego zauwa¿yæ pod MS-DOS, jednak pod Linuxem staje siê to
    wa¿ne. W takim wypadku niezbêdna jest naprawa napêdu.
	</para>

</sect1>

<sect1>
<title>CD-ROM-y</title>

	<para> Napêd CD-ROM opiera siê na optycznym odczytywaniu no¶nika,
    który najczê¶ciej utworzony jest z plastyku,
	
		<footnote><para> Wewn±trz plastyku znajduje siê metalowy dysk.
		</para></footnote>
		
	w którym znajduj± siê ma³e zag³êbienia, s± one umieszczone na spirali
    zaczynaj±cej siê w ¶rodku p³yty. Promieñ lasera trafiaj±c na zag³êbienie
    zostaje odbity w innym kierunku - w ten sposób rozpoznaje siê bity.
	Reszta jest ³atwa - zwyk³a mechanika.
    </para>

	<para> Napêdy CD-ROM w porównaniu z dyskami twardymi s± wolne.
    Przeciêtny dysk twardy ma czas przeszukiwania wynosz±cy oko³o 15
    ms, szybki CD-ROM mo¿e potrzebowaæ dziesi±tych czê¶ci sekundy aby
    odnale¼æ informacje. Transfer jest na ca³kiem przyzwoitym poziomie,
    przy czym aktualnie spotyka siê napêdy z podan± maxymaln± prêdko¶ci±
    odczytu - np. 50x nie oznacza, ¿e napêd uzyskuje taki wynik, jest to
    maxymalna wydajno¶æ napêdu w sprzyjaj±cych warunkach - w okre¶lonej
    strefie p³yty i przez okre¶lony czas. Powolno¶æ napêdu oznacza, ¿e
    zasadniczo nie mo¿e on zast±piæ dysku twardego, jednak¿e jako medium
    instalacyjne ze 'startowalnym' systemem plików spisuj± siê bardzo
    dobrze.
	</para>

	<para> Istnieje kilka sposobów organizacji danych na CD-ROM-ie.
    Najbardziej popularnym jest miêdzynarodowy standard ISO 9660.
    Standard ten opisuje system plików z ograniczeniami wiêkszymi
    ni¿ w systemie FAT, z drugiej strony dziêki swej prostocie mo¿e
    byæ u¿yty przez ka¿dy system operacyjny i przemapowany na dowolny
    system plików.
	</para>

	<para> Dla normalnego Unixowego wykorzystania ISO 9660 nie nadaje
    siê, dlatego powsta³o rozszerzenie nazywane Rock Ridge.
    Format ten zezwala tworzyæ pliki o d³ugich nazwach, ³±cza symboliczne,
    i inne elementy spotykane na innych systemach plików u¿ywanych w Uniksie.
    Do tego Rock Ridge jest zgodny w dó³ - zawiera on poprawn± strukturê
    ISO 9660. Linux obs³uguje oba formaty, rozpoznaje je automatycznie.
    </para>

	<para> System plików to dopiero po³owa sukcesu. Wiêkszo¶æ CD-ROM-ów
    zawiera dane wymagaj±ce specjalnych programów, przy czym wiêkszo¶æ
    z takich programów nie posiada odpowiedników Linuxowych - pozostaje
    dosemu (emulator DOS-a).
	</para>

	<para> Napêd CD-ROM posiada odpowiedni plik urz±dzenia, jego nazwa
    zale¿y od sposobu pod³±czenia np. via SCSI, kartê muzyczn± czy EIDE.
	Wiêcej informacji znajduje siê w li¶cie sterowników</para>
	
</sect1>

<sect1>
<title>Ta¶my</title>

	<para> Streamer u¿ywa ta¶m, podobnie
	
		<footnote><para> Oczywi¶cie jest to znaczne uproszczenie.
		</para></footnote>
		
	jak magnetofon. Ta¶ma ma naturê szeregow±, co oznacza, ¿e aby
    uzyskaæ dan± cze¶æ nale¿y pomin±æ wszystkie poprzednie.
    Dysk mo¿na odczytywaæ losowo - skakaæ z jednego miejsca w drugie.
    Szeregowym dostêp czyni ta¶my urz±dzeniami powolnymi.
	</para>

	<para> Z drugiej strony wykonanie ta¶my jest relatywnie tanie, a dziêki
    mo¿liwo¶ci nawiniêcia du¿ej ilo¶ci ta¶my magnetycznej mo¿na uzyskaæ
    du¿± pojemno¶æ. Czyni to streamery ulubionymi narzêdziami do robienia
    kopii zapasowych - powolno¶æ rekompensowana jest du¿± pojemno¶ci±,
    oraz nisk± cen±.
	</para>

</sect1>

<sect1>
<title>Formatowanie</title>

	<para> <glossterm>Formatowanie</glossterm> jest to proces nanoszenia
    znaków, które u¿ywane s± jako znaczniki ¶cie¿ek i sektorów.
    Przed sformatowaniem dysku powierzchnia magnetyczna jest w stanie
    nieuporz±dkowanym. W czasie formatowania powstaj± ¶cie¿ki, które
    pó¼niej dzielone s± na sektory - w ten sposób nastêpuje uporz±dkowanie
    powierzchni. Aktualnie sprawa ma siê nieco inaczej, jednak jest to
    bez znaczenia. Najwa¿niejsze jest to, ¿e ta¶my nie mo¿na u¿ywaæ przed
    sformatowaniem.
	</para>

	<para> Aktualna terminologia jest nieco myl±ca: w MS-DOS s³owo
    "formatowanie" oznacza tak¿e proces tworzenia systemu plików
    (który omówimy pó¼niej), wiêc jest to kombinacja dwóch procesów.
    Dla celów dyskusji prawdziwe formatowanie nazywane jest
    <glossterm>formatowaniem niskopoziomowym</glossterm>, przy czym
    tworzenie systemu plików nazywane jest <glossterm>formatowaniem
    wysokopoziomowym</glossterm>. W krêgu Unixa istniej± osobne okre¶lenia
    na te dwa procesy: formatowanie, tworzenie systemu plików.
	</para>

	<para> Dyski IDE i niektóre SCSI formatowane s± w fabryce i nie
    wymagaj± ponowienia tej operacji; wiêkszo¶æ ludzi nie musi siê tym
    martwiæ. Prawdê mówi±c, reformatowanie dysku mo¿e spowodowaæ
    spadek wydajno¶ci - czasami trzeba to zrobiæ w specjalny sposób aby
    aktywowaæ automatyczn± zamianê z³ych sektorów, itd.
	</para>

	<para> Dyski, które wymagaj±, lub mog± byæ formatowane wymagaj±
    najczê¶ciej specjalnych programów poniewa¿ logika odpowiedzialna
    za formatowanie ró¿ni siê miêdzy napêdami. Program formatuj±cy
    mo¿e odwo³ywaæ siê do BIOS-u kontrolera, lub jest programem DOS-owskim,
    w obu przypadkach trudno go wykorzystaæ pod Linuxem.
	</para>

	<para> Podczas formatowania mog± pojawiæ siê zepsute miejsca zwane
	<glossterm>zepsutymi blokami</glossterm>, lub <glossterm>zepsutymi
	sektorami</glossterm>. Czasami s± one wewnêtrznie obs³ugiwane przez
    napêd, jednak powinno siê poczyniæ specjalne dzia³ania aby unikn±æ próby
    zapisu takiego miejsca. Logika odpowiedzialna za unikanie takich prób wbudowana jest w
    system plików. Mo¿na równie¿ utworzyæ ma³± partycjê obejmuj±c± 
    b³êdy; jest to dobre podej¶cie w przypadku gdy uszkodzona jest
    du¿a czê¶æ dysku.
	</para>

	<para> Dyskietki formatowane s± za pomoc± <command>fdformat</command>.  
    Urz±dzenie podaje siê jako parametr. Dla przyk³adu: nastêpuj±ce
    polecenie sformatuje dyskietkê HD 1,44 MB:

<screen>
<prompt>$</prompt> <userinput>fdformat /dev/fd0H1440</userinput>
<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.</computeroutput>
<computeroutput>Formatting ... done</computeroutput>
<computeroutput>Verifying ... done</computeroutput>
<prompt>$</prompt>
</screen>

	Zapamietaj, ¿e je¿eli chcesz u¿yæ urz±dzenia autodetekcji
    powiniene¶ najpierw ustawiæ domy¶lny format za pomoc± polecenia
    <command>setfdprm</command>. To samo mo¿na otrzymaæ w nastêpuj±cy
    sposób:

<screen>
<prompt>$</prompt> <userinput>setfdprm /dev/fd0 1440/1440</userinput>
<prompt>$</prompt> <userinput>fdformat /dev/fd0</userinput>
<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.</computeroutput>
<computeroutput>Formatting ... done</computeroutput>
<computeroutput>Verifying ... done</computeroutput>
<prompt>$</prompt>
</screen>

    Nie jest rozs±dnym formatowanie dyskietki do formatu pojemniejszego
    ni¿ zaprojektowany format.
	</para>

	<para> <command>fdformat</command> weryfikuje dyskietkê - sprawdza j±
    pod k±tem wystêpowania zepsutych bloków. Je¿eli taki ponowi sprawdzenie
    kilkakrotnie - w ten weryfikuje siê prawdziwo¶æ b³êdu, np. móg³
    to byæ tylko kurz. Prawdziwy b³±d przerwie proces walidacji, j±dro
    wy¶wietli informacje o b³êdzie we/wy (I/O error) na konsoli lub
    odpowiednia informacja pojawi siê w pliku 
	<filename>/usr/log/messages</filename> (pod warunkiem, ¿e <command>syslog</command>
    dzia³a). <command>fdformat</command> nie potrafi powiedzieæ gdzie
    nast±pi³ b³±d (zazwyczaj nikt o to nie dba - dyskietki s± tak tanie,
    ¿e zepsute najczê¶ciej l±duj± w koszu).

<screen>
<prompt>$</prompt> <userinput>fdformat /dev/fd0H1440</userinput>
<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.</computeroutput>
<computeroutput>Formatting ... done</computeroutput>
<computeroutput>Verifying ... read: Unknown error</computeroutput>
<prompt>$</prompt>
</screen>

	Polecenie <command>badblocks</command> mo¿e zostaæ u¿yte w celu
    sprawdzenia wystêpowania b³êdów na dysku (dyskietce). Program
    nie formatuje dysku, wiêc mo¿esz sprawdzaæ dyski zawieraj±ce
    dane. Poni¿szy przyk³ad sprawdza 3,5 calow± dyskietkê:

<screen>
<prompt>$</prompt> <userinput>badblocks /dev/fd0H1440 1440</userinput>
<computeroutput>718</computeroutput>
<computeroutput>719</computeroutput>
<prompt>$</prompt>
</screen>

	<command>badblocks</command> wypisuje numery uszkodzonych bloków.
    Wiêkszo¶æ systemów plików potrafi omijaæ zepsute czê¶ci dysku -
    informacje o zepsutych blokach zapisywane s± w odpowiednim miejscu, 
    mo¿na je równie¿ modyfikowaæ. Pierwszego sprawdzenia mo¿na dokonaæ tworz±c 
    system plików - <command>mkfs</command> umo¿liwia to, pó¿niejsze 
    sprawdzenia powinny byæ wykonywane za pomoc± <command>badblocks</command>,
    lista zepsutych bloków powinna byæ modyfikowana za pomoc± <command>fsck</command>.
	W pó¿niejszej czê¶ci ksi±¿ki znajdziesz opis <command>mkfs</command> i
	<command>fsck</command>.</para>

	<para> Wiele nowoczesnych dysków wykrywa zepsute obszary automatycznie,
    czê¶æ z nich ma mechanizm naprawy polegaj±cy na u¿ywaniu w takim
    przypadku bloków z zarezerwowanej puli. Jest to niewidoczne
    dla systemu operacyjnego. Wiêcej informacji powinno znajdowaæ siê
    w dokumentacji twojego dysku. Wykrywalne b³êdy pojawiaj± siê
    dopiero gdy wszystkie zapasowe bloki zostaj± wykorzystane, jednak
    taka sytuacja zdarza siê najczê¶ciej gdy dysk nie nadaje siê ju¿ do niczego.
	</para>

</sect1>

<sect1>
<title>Partycje</title>

	<para> Ka¿dy dysk twardy mo¿e zostaæ podzielony na 
	<glossterm>partycje</glossterm>. Ka¿da partycje stanowi osobn± czê¶æ,
    tak jakby by³a osobnym dyskiem. Idea polega na tym, ¿e chc±c mieæ
    dwa systemy operacyjne na jednym dysku mo¿esz stworzyæ odpowiednie
    partycje. Ka¿dy z systemów bêdzie wykorzystywa³ swoj± czê¶æ na w³asny
    sposób, inne nie bêd± go interesowaæ. Dziêki temu kilka systemów
    operacyjnych mo¿e koegzystowaæ na jednym dysku.
	</para>

	<para> Dyskietki nie posiadaj± partycji, nie istnieje taka
    potrzeba - ze wzglêdu na ich niewielk± pojemno¶æ.
	CD-ROM-y zazwyczaj nie s± dzielone poniewa¿ ³atwiej u¿ywaæ ich
    jako jedn± ca³o¶æ, rzadko kiedy zdarza siê potrzeba umieszczenia
    na nich kilku systemów operacyjnych.
	</para>

<sect2>
<title>MBR, sektory ³aduj±ce i tablica partycji</title>

	<para> Informacje o podziale dysku umieszczone s± w pierwszym sektorze
    (dok³adniej: pierwszym sektorze pierwszej ¶cie¿ki pierwszej 
    p³aszczy¼ny). Sektor ten nazwany jest 
	<glossterm>g³ównym rekordem ³aduj±cym (master boot record)</glossterm> (MBR)
    ; czê¶æ ta odczytywana jest przez BIOS w czasie startu komputera
    Zawiera ma³y program (~400 bajtów) który odczytuje tablicê partycji,
    po czym odczytuje pierwszy sektor aktywnej partycji - 
    <glossterm>rekord ³aduj±cy</glossterm>. W sektorze tym powinien
    znajdowaæ siê ma³y program odczytuj±cy czê¶æ systemu operacyjnego
    niezbêdn± do ³adowania, po czym uruchomiæ j±.
	</para>

	<para> Schemat partycjonowania dysku nie jest wbudowany w sprzêt,
    ani w BIOS. Jest to konwencja u¿ywana w wielu systemach operacyjnych.
    Nie wszystkie z nich przestrzegaj± j±, istniej± równie¿ pewne wyj±tki.
    Niektóre z systemów zajmuj± jedn± partycjê, na której u¿ywaj± w³asnego
    schematu podzia³u. Takie dzia³anie umo¿liwia zainstalowanie kilku systemów
    operacyjnych, natomiast w przypadku systemów nie obs³uguj±cych partycji 
    jeden dysk oznacza mo¿liwo¶æ zainstalowania tylko jednego systemu
    operacyjnego.
	</para>

	<para> Zalecanym jest spisanie na kartce informacji o podziale dysku,
    w ten sposób uszkodzenie tablicy partycji nie spowoduje straty
    danych - dziêki zapisanym informacjom bêdziesz móg³ j± odtworzyæ.
	Zepsuta tablica partycji mo¿e zostaæ naprawiona programem
	<command>fdisk</command>. Oto informacje o partycjach uzyskane poleceniem
    <command>fdisk -l</command>:
	</para>

<screen>
<prompt>$</prompt> <userinput>fdisk -l /dev/hda</userinput>
<computeroutput></computeroutput>
<computeroutput>Disk /dev/hda: 15 heads, 57 sectors, 790 cylinders</computeroutput>
<computeroutput>Units = cylinders of 855 * 512 bytes</computeroutput>
<computeroutput></computeroutput>
<computeroutput>   Device Boot  Begin   Start     End  Blocks   Id  System</computeroutput>
<computeroutput>/dev/hda1           1       1      24   10231+  82  Linux swap</computeroutput>
<computeroutput>/dev/hda2          25      25      48   10260   83  Linux native</computeroutput>
<computeroutput>/dev/hda3          49      49     408  153900   83  Linux native</computeroutput>
<computeroutput>/dev/hda4         409     409     790  163305    5  Extended</computeroutput>
<computeroutput>/dev/hda5         409     409     744  143611+  83  Linux native</computeroutput>
<computeroutput>/dev/hda6         745     745     790   19636+  83  Linux native</computeroutput>
<prompt>$</prompt>
</screen>

</sect2>

<sect2>
<title>Partycje rozszerzone i logiczne</title>

	<para> Oryginalny schemat partycjonowania szybko okaza³ siê niewystarczaj±cy.
    Wielu ludzi chcia³o mieæ wiêcej ni¿ cztery systemy operacyjne na
    jednym dysku (Linux, MS-DOS, OS/2, Minix, FreeBSD, NetBSD, Windows/NT, 
    itp.), równie¿ czê¶æ ludzi chcia³a rozmie¶ciæ jeden system na kilku
    partycjach. Dla przyk³adu: w Linuksie swap ze wzglêdu wydajno¶ci
    umieszcza siê na osobnej partycji (wiêcej poni¿ej).
	</para>

	<para> Aby omin±æ te ograniczenia wymy¶lono <glossterm>partycje rozszerzone</glossterm>.
    Trik ten umo¿liwia dzielenie <glossterm>podstawowej partycji</glossterm> na
    podpartycje.
	Podstawowa partycja, która jest podzielona nazywa siê <glossterm>partycj±
    rozszerzon±</glossterm>; podpartycja nazywa siê <glossterm>partycj± logiczn±
    </glossterm>. Zachowuj± siê
	
		<footnote><para> Nie logicznie?</para></footnote>
		
	jak zwyk³e partycje, ale tworzone s± w odmienny sposób.
    Nie istnieje ró¿nica w prêdko¶ci.
	</para>

	<para> Struktura partycji mog³aby wygl±daæ nastêpuj±co 
	<xref linkend="hard-disk-layout"/>. Dysk podzielony jest na trzy
    partycje podstawowe, druga partycja jest podzielona na dwa dyski
    logiczne. Czê¶æ dysku nie jest podzielona.
	Dysk oraz ka¿da z partycji posiada rekord ³aduj±cy.</para>

		<figure id="hard-disk-layout" float="1">
		<title>Przyk³adowy podzia³ dysku.</title>
		<graphic fileref="hd-layout"></graphic>
		</figure>

</sect2>

<sect2>
<title>Typ partycji</title>

	<para> Tablica partycji zawiera, dla ka¿dej, bajt oznaczaj±cy
    typ partycji. Ma to na celu zidentyfikowanie systemu u¿ywaj±cego
    danej partycji, lub celu u¿ycia. Celem by³o utrudnienie sytuacji,
    w której dwa systemy operacyjne u¿ywa³yby tej samej partycji.
    Jednak, w rzeczywisto¶ci wiele systemów nie interesuje siê
    zawarto¶ci± tego¿ bajtu (Linux ma go w nosie). Co gorzej, niektóre
    z nich interpretuj± go niepoprawnie - DR-DOS ignoruje najbardziej
    znacz±cy bit tego¿ bajtu, przy czym inne systemy tego nie robi±.
	</para>

	<para> Nie istnieje standard zawieraj±cy informacje o dok³adnym znaczeniu
    poszczególnych warto¶ci, czê¶æ z powszechnie akceptowanych
	zawarta jest w <xref linkend="partition-ids"/>. T± sam± list±
    pos³uguje siê program <command>fdisk</command>.</para>

	<table id="partition-ids">
	<title>Typy partycji (z Linuksowego programu <command>fdisk</command>).</title>
	
	<tgroup cols="6">
	<tbody>
	
	<row>
	<entry>0</entry> <entry>Pusta</entry>
	<entry>40</entry> <entry>Venix 80286</entry>
	<entry>94</entry> <entry>Amoeba BBT</entry>
	</row>
	
	<row>
	<entry>1</entry> <entry>DOS 12-bit FAT</entry>
	<entry>51</entry> <entry>Novell?</entry>
	<entry>a5</entry> <entry>BSD/386</entry>
	</row>
	
	<row>
	<entry>2</entry> <entry>XENIX root</entry>
	<entry>52</entry> <entry>Microport</entry>
	<entry>b7</entry> <entry>BSDI fs</entry>
	</row>
	
	<row>
	<entry>3</entry> <entry>XENIX usr</entry>
	<entry>63</entry> <entry>GNU HURD</entry>
	<entry>b8</entry> <entry>BSDI swap</entry>
	</row>
	
	<row>
	<entry>4</entry> <entry>DOS 16-bitf &lt;32M</entry>
	<entry>64</entry> <entry>Novell</entry>
	<entry>c7</entry> <entry>Syrinx</entry>
	</row>
	
	<row>
	<entry>5</entry> <entry>Rozszerzona</entry>
	<entry>75</entry> <entry>PC/IX</entry>
	<entry>db</entry> <entry>CP/M</entry>
	</row>
	
	<row>
	<entry>6</entry> <entry>DOS 16-bit &gt;=32M</entry>
	<entry>80</entry> <entry>Old MINIX</entry>
	<entry>e1</entry> <entry>DOS access</entry>
	</row>
	
	<row>
	<entry>7</entry> <entry>OS/2 HPFS</entry>
	<entry>81</entry> <entry>Linux/MINIX</entry>
	<entry>e3</entry> <entry>DOS R/O</entry>
	</row>
	
	<row>
	<entry>8</entry> <entry>AIX</entry>
	<entry>82</entry> <entry>Linux swap</entry>
	<entry>f2</entry> <entry>DOS, druga</entry>
	</row>
	
	<row>
	<entry>9</entry> <entry>AIX, startowalna</entry>
	<entry>83</entry> <entry>Naturalna dla Linuxa</entry>
	<entry>ff</entry> <entry>BBT</entry>
	</row>
	
	<row>
	<entry>a</entry> <entry>OS/2 Boot Manager</entry>
	<entry>93</entry> <entry>Amoeba</entry>
	<entry></entry> <entry></entry>
	</row>
	
	</tbody>
	</tgroup>
	</table>

</sect2>

<sect2>
<title>Dzielenie dysku twardego</title>

	<para> Istnieje wiele programów s³u¿±cych do tego celu.
    Wiêkszo¶æ systemów operacyjnych zawiera w³asne, których powinno siê
    u¿ywaæ - mog± one robiæ co¶ niezwyk³ego, czego nie potrafi± zrobiæ inne.
    Wiele z tych programów nazywa siê <command>fdisk</command>, w³±czaj±
    program Linuxa - odmianê tego¿ programu. Szczegó³y dotycz±ce programu
    znajduj± siê w jego podrêczniku. 
	Istnieje równie¿ <command>cfdisk</command>, który jest '³adniejsz±' wersj±
    <command>fdiska</command>.
	</para>

	<para> U¿ywaj±c dysków IDE musisz upewniæ siê, ¿e partycja z obrazem j±dra
    znajdzie siê poni¿ej 1024 cylindra. Jest to wymagane poniewa¿ proces
    bootowania opiera siê na dzia³aniu BIOS-u, a ten nie potrafi
    obs³u¿yæ wiêcej ni¿ 1024 cylindrów. Mo¿naby stworzyæ partycjê
    zaczynaj±c± siê poni¿ej tej granicy, jednak nie jest to dobrym
    pomys³em - fragmentacja dysku, lub niefortunne umieszczenie pliku
    mog± spowodowaæ, ¿e nie bêdzie mo¿na uruchomiæ komputera.
    Dla ¶wiêtego spokoju, upewnij siê, ¿e ca³a partycja znajduje siê poni¿ej
    1024 cylindra.
	</para>

	<para> Niektóre nowsze BIOS-y i dyski IDE potrafi± obs³u¿yæ wiêcej
    ni¿ 1024 cylindrów, je¿eli tak jest masz problem z g³owy, je¿eli
    nie jeste¶ pewien za³ó¿, ¿e BIOS nie dzia³a - oszczêdzi Ci to k³opotów.
	</para>

	<para> Ka¿da partycja powinna mieæ parzyst± liczbê sektorów -
    Linux u¿ywa systemu plików z blokiem o rozmiarze 1 kB - 2 sektory.
    Nieparzysta liczba sektorów powoduje, ¿e ostatni z nich nie jest
    u¿ywany, niektóre wersje 
	<command>fdiska</command> powiedz± Ci o tym.
	</para>

	<para> Zmiana rozmiaru partycji zazwyczaj wymaga utworzenia
    kopi zapasowej (najlepiej ca³ego dysku), usuniêcia partycji, utworzenia
    nowej i odtworzenia danych. Je¿eli powiêkszasz partycjê powiniene¶
    stworzyæ kopie zapasowe usuwanych partycji (których miejsce u¿yjesz aby
    utworzyæ wiêksz± partycjê).
	</para>

	<para> Poniewa¿ zmiana rozmiaru partycji nie jest mi³± czynno¶ci± powiniene¶
    stworzyæ odpowiednie za pierwszym razem - zastanów siê przed za³o¿eniem
    partycji, pomy¶l o przysz³o¶ci. Je¿eli instalujesz system z medium
    niewymagaj±cego obecno¶ci cz³owieka (powiedzmy z CD-ROM-u, a nie dyskietek :-) warto
    najpierw przetestowaæ kilka rozwi±zañ. Taki system mo¿na bez
    problemu usun±æ - nie ma tam ¿adnych danych u¿ytkowników, itd.
	</para>

	<para> Istnieje program dla MS-DOS, nazywaj±cy siê
	<command>fips</command>, który zmienia rozmiar partycji
    MS-DOS bez potrzeby tworzenia kopii zapasowej i odtwarzania,
    w przypadku innych systemów plików musisz wykonaæ te kroki.
	</para>

</sect2>

<sect2>
<title>Pliki urz±dzeñ i partycje</title>

	<para> Ka¿da z partycji posiada swój plik urz±dzenia. Plik taki
    ma czê¶æ wskazuj±c± na dysk (innymi s³owy nazwa dysku), zakoñczon±
    numerem. Liczby 1-4 wskazuj± na partycje podstawowe (obojêtnie
    od liczby partycji - mo¿esz mieæ partycje 2, 4, itp. ),
    5-8 oznaczaj± dyski logiczne ( niezale¿nie od partycji podstawowej,
    na której siê znajduj±). Dla przyk³adu: 
	<filename>/dev/hda1</filename> oznacza pierwsz± podstawow± partycjê
    na dysku hda, <filename>/dev/sdb7</filename> jest trzeci±
    partycj± rozszerzon± na drugim dysku SCSI.
	Lista urz±dzeñ zawiera wiêcej szczegó³ów.</para>

</sect2>

</sect1>

<sect1>
<title>System plików</title>

<sect2>
<title>Czym jest system plików?</title>

	<para> <glossterm>System plików</glossterm> to metody i struktury
    danych u¿ywane przez system operacyjny u¿ywane w celu
    zapisania informacji o plikach i ich zawarto¶ci na danej partycji;
    jest to sposób organizacji plików na dysku. S³owo to jest
    u¿ywane równie¿ w znaczeniu dysku, partycji. Mo¿e to byæ nieco
    myl±ce.
	</para>

        <para> Ró¿nica miêdzy dyskiem a partycj±, lub systemem plików
        jest wa¿na. Kilka programów (w³±czaj± programy tworz±ce
        systemy plików) pracuj± opieraj±c siê na sektorach;
        je¿eli w polu dzia³ania istnieje system plików zostanie
        on zniszczony, lub powa¿nie uszkodzony. Wiêkszo¶æ programów
        pracuje w oparciu o system plików, nie bêd± one pracowaæ
        na partycji nie zawieraj±cej go (lub na partycji zawieraj±cej
        z³y system plików).
        </para>

	<para> Przed u¿yciem partycji, lub dysku jako system pliku nale¿y
    odpowiednio go przygotowaæ, stworzyæ odpowiednie struktury.
    Proces ten nazywany jest 
	<glossterm>tworzeniem systemu plików</glossterm>.</para>

	<para> Wiêkszo¶æ systemów plików u¿ywanych przez Unixy jest ogólnie
    podobna (lub s± one funkcjonalnie podobne), jednak szczegó³y mog±
    siê znacz±co ró¿niæ. Wspólnymi pomys³ami s±:
	<glossterm>superblok</glossterm>,
	<glossterm>iwêze³</glossterm>, <glossterm>blok danych</glossterm>,
	<glossterm>blok katalogu</glossterm>, oraz <glossterm>blok po¶redni
	</glossterm>.  Superblok zawiera informacje o systemie jako ca³o¶ci, np.
    rozmiar (dok³adna zawarto¶æ zale¿y od systemu plików).
	Iwêze³ zawiera wszelkie informacje o pliku, za wyj±tkiem jego nazwy.
    Nazwa przechowywana jest w katalogu, razem z numerem iwêz³a.
    Wpis katalogu zawiera nazwê, liczbê iwêz³ów plików.
	Iwêze³ zawiera numery kilku bloków danych, które u¿ywane s± do przechowywania
    pliku. Automatycznie allokowane miejsce pozwala przechowywaæ tylko kilka
    numerów, jednak w razie potrzeby zostaje dynamicznie allokowana
    dodatkowa przestrzeñ. Bloki allokowane dynamicznie nazywaj± siê bezpo¶rednimi;
    nazwa wskazuje, ¿e w celu znalezienia numeru bloku danych nale¿y znale¼æ
    pierwszy blok po¶redni.
	</para>

	<para> Zazwyczaj system plików UNIXA pozwala tworzyæ
	<glossterm>dziury</glossterm> w plikach (s± one tworzone za pomoc±
    <function>lseek</function>; sprawd¼ stronê podrêcznika), oznacza to,
    ¿e system udaje wystêpowanie zera na danym miejscu, jednak nie
    zajmuje ono dysku. Dzieje siê tak czêsto w przypadku ma³ych binariów,
    bibliotek dzielonych Linuxa, niektórych baz danych i przy innych okazjach.
    Dziury przechowywane s± poprzez zapisywanie specjalne warto¶ci w polu
    adresu bloku po¶redniego, lub iwêz³a. Ten specjalny adres oznacza, ¿e
    w pliku jest dziura.
	</para>

	<para> Dziury s± ca³kiem po¿yteczne. Na systemie autora,
    prosty pomiar pokaza³, i¿ oszczêdzono w ten sposób 4 MB dla 200 MB danych.
	Ten system zawiera relatywnie ma³o programów i ¿adnych baz danych.
	</para>

</sect2>

<sect2>
<title>Paleta systemów plików</title>

	<para> Linux obs³uguje kilka typów systemów plików. Najwa¿niejszymi z
    nich s±:

	<glosslist>
	<glossentry>
	<glossterm>minix</glossterm>
		<glossdef><para> 
		Najstarszy, uwa¿any za najbardziej niezawodny, jednak posiada
        on znaczne ograniczenia (brakuje niektórych znaczników czasu,
        nazwy plików mog± mieæ maxymalnie 30 znaków, system plików mo¿e
        mieæ co najwy¿ej 64 MB ).
		</para></glossdef></glossentry>
		
	<glossentry>
	<glossterm>xia</glossterm>
		<glossdef><para> 
		Zmodyfikowana wersja systemu minix, w której zosta³y podniesione
        limity: maxymalnej d³ugo¶ci nazwy, oraz rozmiaru systemu plików.
        ¯adne nowo¶ci nie zosta³y wprowadzone. Nie jest zbyt
        popularny, jednak istniej± dowody, i¿ dzia³a ca³kiem dobrze.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm>ext2</glossterm>
		<glossdef><para> 
		Najbogatszy w mo¿liwo¶ci system plików Linuxa,
        aktualnie jest najbardziej popularny. Zaprojektowany
        z my¶l± o zgodno¶ci wzwy¿, dziêki czemu powstanie nowej
        wersji nie oznacza potrzeby konwersji.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm>ext</glossterm>
		<glossdef><para> 
		Starsza wersja ext2, nie jest zgodna wzwy¿. Aktualnie nie
        u¿ywany, wiêkszo¶æ ludzi u¿ywa ext2.
		</para></glossdef></glossentry>
    
    <glossentry>
	<glossterm>Powstaj±ce systemy</glossterm>
        <glossdef><para> 
        Aktualnie powstaje kilka systemów 'z kartotek±', ich cechami s±
        szybko¶æ operacji na du¿ej ilo¶ci plików, oraz algorytmy obs³uguj±ce,
        które pozwalaj± na samoczynne naprawianie siê systemu w czasie
        pracy.
        </para></glossdef></glossentry>
    
	</glosslist>
	</para>
    
	<para> J±dro Linuxa potrafi (je¿eli tak je skompilowano) obs³u¿yæ
    systemy plików obcego pochodzenia. Systemom takim czêsto brakuje
    pewnych cech znanych z rozwi±zañ rdzennych dla Unixa, czasami
    posiadaj± one dziwne ograniczenia.

	<glosslist>

	<glossentry>
	<glossterm>msdos</glossterm>
		<glossdef><para> 
		Kompatybliny z MS-DOS (OS/2 i Windows NT) system plików FAT.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm>usmdos</glossterm>
		<glossdef><para> 
		Rozszerzona wersja systemu msdos, która umo¿liwia tworzyæ
        d³ugie nazwy plików, ustanawiaæ w³a¶cicieli, prawa dostêpu,
        ³±cza, oraz pliki urz±dzeñ. Dziêki niemu zwyk³y system
        plików msdos zyskuje cechy znane w ¶rodowisku Unix, oraz
        umo¿liwia zainstalowanie Linuxa na partycji MS-DOS.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm>iso9660</glossterm>
		<glossdef><para> 
		Statdardowy system plików p³yt CD-ROM; popularne rozszerzenie "Rock
        Ridge" rozpoznawane jest automatycznie.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm>nfs</glossterm>
		<glossdef><para> 
		Sieciowy System Plików Suna umo¿liwia dzielenie systemów plików
        poprzez sieæ, umo¿liwia tworzenie bezdyskowych stacji, itp.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm>hpfs</glossterm>
		<glossdef><para> 
		System plików OS/2.
		</para></glossdef></glossentry>

	<glossentry>
	<glossterm>sysv</glossterm>
		<glossdef><para> 
		U¿ywany przez SystemV/386, Coherenta i Xenixa.
		</para></glossdef></glossentry>

	</glosslist>
	</para>

	<para> Wybór systemu plików czêsto podyktowany jest spraw± kompatybilno¶ci.
    Je¿eli musisz mo¿esz wykorzystywaæ te systemy, jednak w przypadku
    gdy kompatybilno¶æ nie jest wymagana najlepiej wybraæ ext2,
    poniewa¿ posiada on wszelkie potrzebne mo¿liwo¶ci i do tego jest wydajny. 
	</para>

	<para> Istnieje równie¿ system plików proc, najczê¶ciej jest on
    dostêpny poprzez katalog <filename>/proc</filename>, nie jest to rzeczywisty
    system plików - jest to specjalne rozwi±zanie pozwalaj±ce sprawdzaæ
    i modyfikowaæ, niektóre parametry j±dra podczas pracy systemu.
	Takie podej¶cie umo¿liwia wgl±d w j±dro za pomoc± zwyk³ych
    narzêdzi do manipulacji plikami. Dla przyk³adu aby odczytaæ aktualn±
    listê procesów mo¿na zrobiæ co¶ takiego:

<screen>
<prompt>$</prompt> <userinput>ls -l /proc</userinput>
<computeroutput>total 0
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 1
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 63
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 94
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 95
dr-xr-xr-x   4 root     users           0 Jan 31 20:37 98
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 99
-r--r--r--   1 root     root            0 Jan 31 20:37 devices
-r--r--r--   1 root     root            0 Jan 31 20:37 dma
-r--r--r--   1 root     root            0 Jan 31 20:37 filesystems
-r--r--r--   1 root     root            0 Jan 31 20:37 interrupts
-r--------   1 root     root      8654848 Jan 31 20:37 kcore
-r--r--r--   1 root     root            0 Jan 31 11:50 kmsg
-r--r--r--   1 root     root            0 Jan 31 20:37 ksyms
-r--r--r--   1 root     root            0 Jan 31 11:51 loadavg
-r--r--r--   1 root     root            0 Jan 31 20:37 meminfo
-r--r--r--   1 root     root            0 Jan 31 20:37 modules
dr-xr-xr-x   2 root     root            0 Jan 31 20:37 net
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 self
-r--r--r--   1 root     root            0 Jan 31 20:37 stat
-r--r--r--   1 root     root            0 Jan 31 20:37 uptime
-r--r--r--   1 root     root            0 Jan 31 20:37 version</computeroutput>
<prompt>$</prompt>
</screen>

	(Poka¿e to kilka dodatkowych plików, które nie odpowiadaj± procesom.
    Powy¿szy przyk³ad zosta³ skrócony.)
	</para>

	<para> Zapamiêtaj, ¿e pomimo swej nazwy "system plików" nie potrzeba
    dla niego ¿adnego miejsca (oprócz miejsca na katalog /proc),
    niektóre z plików posiadaj± rozmiar ró¿ny od zera, jest fikcyjny tak
    samo jak ca³y system plików - stanowi czê¶æ informacji dostarczanej przez 
    j±dro, ¿aden bajt dysku nie jest u¿yty.</para>
</sect2>

<sect2>
<title>Które systemy plików powinnych byæ u¿ywane?</title>

	<para> Zazwyczaj bezsensownym jest u¿ywanie kilku typów systemów
    plików. Aktualnie ext2 jest najpopularniejszym i prawdopodobnie
    stanowi najlepszy wybór. Zale¿nie od miejsca zu¿ywanego przez
    sam system plików, prêdko¶ci, pewno¶ci dzia³ania,
    kompatybilno¶ci i innych powodów mo¿na wybraæ inny system plików.
    Ka¿dy przypadek wymaga oddzielnego podej¶cia.
	</para>
	
</sect2>

<sect2>
<title>Tworzenie systemu plików</title>

	<para> System plików jest tworzony (inicjalizowany) przez 
    <command>mkfs</command>. Aktualnie istnieje kilka osobnych programów
    dla ka¿dego systemu plików.
    Polecenie <command>mkfs</command> po¶redniczy miêdzy nimi a u¿ytkownikiem.
    Typ wybierany jest za pomoc± opcji <option>-t typ</option>.</para>

	<para> Programy wywo³ywane przez <command>mkfs</command> mog± wymagaæ 
    innych opcji. Wspólne i najwa¿niejsze podane s± poni¿ej; zobacz
    odpowiednie strony podrêcznika.

	<glosslist>
	<glossentry>
	<glossterm><option>-t typ</option></glossterm>
		<glossdef><para> 
		Wybierz system plików.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm><option>-c</option></glossterm>
		<glossdef><para> 
		 Sprawd¼ czy s± jakie¶ zepsute bloki, inicjalizuj listê
         z³ych bloków odpowiednio.
		</para></glossdef></glossentry>
	
	<glossentry>
	<glossterm>-l plik</glossterm>
		<glossdef><para> 
		Odczytaj z pliku listê z³ych bloków.
		</para></glossdef></glossentry>
	</glosslist>
	</para>

	<para> Aby na dyskietce utworzyæ system plików ext2 nale¿y wykonaæ nastêpuj±ce polecenia:

<screen>
<prompt>$</prompt> <userinput>fdformat -n /dev/fd0H1440</userinput>
<computeroutput>Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done</computeroutput>
<prompt>$</prompt> <userinput>badblocks /dev/fd0H1440 1440 $>$ bad-blocks</userinput>
<prompt>$</prompt> <userinput>mkfs -t ext2 -l bad-blocks /dev/fd0H1440</userinput>
<computeroutput>mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

Writing inode tables: done
Writing superblocks and filesystem accounting information: done</computeroutput>
<prompt>$</prompt>
</screen>
	</para>

	<para>
	Najpierw sformatowano dyskietkê ( opcja <option>-n</option> wy³±cza
    sprawdzanie wystêpowania z³ych bloków ), pó¼niej sprawdzili¶my
    czy dyskietka nie posiada zepsutych obszarów za pomoc± programu
    <command>badblocks</command>, wyj¶cie skierowali¶my do pliku.
    Ostatecznie stworzyli¶my system plików, zainicjowali¶my listê
    z³ych bloków zawarto¶ci± pliku.
	</para>

	<para> Mo¿na by³o u¿yæ opcji <option>-c</option> programu
	<command>mkfs</command>, zamiast uruchamiaæ program <command>badblocks</command>
	Poni¿szy przyk³ad dzia³a tak:

<screen>
<prompt>$</prompt> <userinput>mkfs -t ext2 -c /dev/fd0H1440</userinput>
<computeroutput>mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

Checking for bad blocks (read-only test): done
Writing inode tables: done
Writing superblocks and filesystem accounting information: done</computeroutput>
<prompt>$</prompt>
</screen>

	Opcja <option>-c</option> jest pewniejsza ni¿ u¿ycie
	<command>badblocks</command>, jednak program <command>badblocks</command> 
    jest niezbêdny do sprawdzania istniej±cych systemów plików.</para>
	
	<para> Aby przygotowaæ dysk nale¿y wykonaæ podobne czynno¶ci, przy czym
    formatowanie nie jest potrzebne.
	</para>

</sect2>

<sect2 id="mount-and-umount">
<title>Montowanie i odmontowywanie</title>

	<para> Przed u¿yciem systemu plików nale¿y go <glossterm>zamountowaæ</glossterm>.
    System operacyjny sprawdza, niektóre czê¶ci systemu plików w
    celu upewnienia siê, ¿e dzia³a. Poniewa¿ w Unixie pliki przechowywane
    w jednym drzewie nowy system plików bêdzie tworzy³ zawarto¶æ jakiego¶
    katalogu.
	</para>

	<para> Dla przyk³adu: <xref linkend="hd-mount-root"/> pokazuje systemy plików,
    ich katalogi g³ówne zosta³y zaznaczone.
	Montuj±c ostatnie dwa systemy plików odpowiednio w katalogu
    <filename>/home</filename> i <filename>/usr</filename>, wszystko to
    na pierwszym systemie plików, otrzymamy spójne drzewo katalogów:
	<xref linkend="hd-mount-all"/>.</para>

		<figure id="hd-mount-root" float="1">
		<title>Trzy osobne systemy plików.</title>
		<graphic fileref="hd-mount-separate"></graphic>
		</figure>

		<figure id="hd-mount-all" float="1">
		<title><filename>/home</filename> i <filename>/usr</filename> zosta³y zamontowane.</title>
		<graphic fileref="hd-mount-mounted"></graphic>
		</figure>

	<para> Montowañ mo¿na dokonaæ w sposób nastêpuj±cy:

<screen>
<prompt>$</prompt> <userinput>mount /dev/hda2 /home</userinput>
<prompt>$</prompt> <userinput>mount /dev/hda3 /usr</userinput>
<prompt>$</prompt>
</screen>

	Pierwszy argument oznacza plik urz±dzenia zawieraj±cy
    system plików. Drugi argument to katalog, w którym nale¿y
    zamontowaæ zawarto¶æ urz±dzenia. Po zamontowaniu zawarto¶æ
    systemu plików podanego urz±dzenia staje siê zawarto¶ci±
    katalogu.
	
	Zauwa¿ ró¿nicê miêdzy urz±dzeniem <filename>/dev/hda2</filename>, a
	<filename>/home</filename>. Plik urz±dzenia umo¿liwia dostêp
    do surowych danych, natomiast, po zamontowaniu, katalog udostêpnia
    te dane w postaci plików i katalogów.
    Katalog, do którego montujemy system plików nazywany jest
	<glossterm>punktem montowania</glossterm>.</para>

	<para> Linux obs³uguje wiele systemów plików.  <command>mount</command> 
    próbuje odgadn±æ typ systemu (co mo¿e mu siê nie udaæ). Aby
    jawnie podaæ system plików nale¿y pos³u¿yæ siê opcj±
	<option>-t typ</option>;
    Aby zamontowaæ dyskietkê MS-DOS:

<screen>
<prompt>$</prompt> <userinput>mount -t msdos /dev/fd0 /floppy</userinput>
<prompt>$</prompt>
</screen>
	</para>

	<para> Punkt montowania nie powinien zawieraæ plików - bêd±
    one niedostêpne a¿ do odmontowania systemu plików (otwarte
    pliki bêd± nadal dostêpne).
	Nie czyni to szkody, a czasami mo¿e byæ po¿yteczne:
	za³ó¿my, ¿e <filename>/tmp</filename> i <filename>/var/tmp</filename> 
    s± synonimami, niech <filename>/tmp</filename> bêdzie ³±czem symbolicznym
    do <filename>/var/tmp</filename>. Podczas startu systemu, przed zamontowaniem
    <filename>/var</filename>, katalog <filename>/var/tmp</filename> znajduj±cy
    siê na g³ównym systemie plików jest u¿ywany.
	Montuj±c <filename>/var</filename> przes³aniamy <filename>/var/tmp</filename>.
    Je¿eli <filename>/var/tmp</filename> nie istnia³by na g³ównym systemie
    plików nie mo¿naby tworzyæ plików tymczasowych przez zamontowaniem
	<filename>/var</filename>.</para>

	<para> Je¿eli nie zamierzasz zmieniaæ systemu plików u¿yj opcji
	<option>-r</option> - w ten sposób zamontujesz go w trybie <glossterm>
    wy³±cznie do odczytu</glossterm>. J±dro odrzuci wszelkie próby zapisu
    , oraz nie bêdziê aktualizowaæ czasu dostêpu do iwêz³ów.
    Montowanie w trybie wy³±cznie-do-odczytu jest niezbêdne dla niezapisywalnych
    mediów (np. CD-ROM-ów).
	</para>

	<para> Uwa¿ny czytelnik zapewne zauwa¿y³ pewnien logiczny problem.
    Jak mo¿na zamontowaæ pierwszy system plików (nazywany 
	<glossterm>g³ównym</glossterm>, skoro nie mo¿na go zamontowaæ jako 
    podkatalog innego? Có¿, dzieje siê tak za spraw± magii.
	
		<footnote><para> Wiêcej informacji znajdziesz w 
		Kernel Hacker's	Guide.</para></footnote>
		
	G³ówny system plików jest magicznie montowany w czasie starty
    systemu. Je¿eli nie mo¿e zostaæ zamontowany system nie uruchomi siê.
    Nazwa pierwszego systemu plików jest albo wkompilowana w j±dro,
    albo ustawiona za pomoc± LILO, lub <command>rdev</command>.
	</para>

	<para> G³ówny system plików jest najczê¶ciej montowany jako
    wy³±cznie-do-odczytu. Pó¼niej skrypt startowy uruchamia
    <command>fsck</command> w celu walidacji poprawno¶ci, je¿eli
    nie wykryto b³êdów system plików zostaje przemontowany
    do trybu zapisywalnego. 
	<command>fsck</command> nie mo¿e byæ uruchamiany na zamontowanym
    systemie plików poniewa¿ wszelkie poczynione zmiany spowodowa³yby
    wadliw± pracê tego programu i prawdopodobn± utratê danych.
    Jednak¿e system plików znajduje siê w trybie tylko-do-odczytu i
    <command>fsck</command> mo¿e go zmieniaæ, operacja
    przemontowywania usunie z pamiêci wszelkie poczynione zmiany i
    nie dojdzie do uszkodzenia systemu plików.
    </para>

	<para> W wielu systemach u¿ywa siê kilku systemów plików, które
    powinny zostaæ zamontowane automatycznie podczas startu systemu.
	Podaje je siê w pliku <filename>/etc/fstab</filename> (zobacz
    stronê odpowiedni± stronê podrêcznika).
    Dok³adne szczegó³y dotycz±ce tego procesu mog± siê ró¿niæ - s±
    zale¿ne od administratora, zobacz sekcjê 
    <xref linkend="boots-and-shutdowns"/>.</para>

	<para> Je¿eli system plików nie jest ju¿ potrzeby nale¿y go odmontowaæ
    poleceniem <command>umount</command>.
	
		<footnote><para> Oczywi¶cie powinno byæ 
		<command>unmount</command>, jednak¿e n zniknê³o w latach 70 i nie
        powróci³o od tamtego czasu. Znalezione proszê zwróciæ 
        Laboratoriom Bella, NJ.</para>
		</footnote>
		
	<command>umount</command> potrzebuje jednego argumentu -
	systemu plików.
    Oto jak odmontowaæ systemu plików zamontowane w poprzednim
    przyk³adzie:
<screen>
<prompt>$</prompt> <userinput>umount /dev/hda2</userinput>
<prompt>$</prompt> <userinput>umount /usr</userinput>
<prompt>$</prompt>
</screen>
	</para>

	<para> Zobacz odpowiedni± stronê podrêcznika. Nale¿y pamiêtam, ¿e
    nale¿y odmontowaæ system plików przed wyci±gniêciem jego no¶nika
    (np. dyskietki). 
	<emphasis>Nie wyci±gaj dyskietki bez jej odmontowania!
	</emphasis> Informacje zapisywane s± w odpowiednich buforach, w pamiêci
    i tylko co jaki¶ czas nastêpuje aktualizacja, wyci±gaj±c dyskietkê w
    najlepszym przypadku stracisz dane, w najgorszym zniszczysz system plików.
	</para>

	<para> Montowanie i odmontowywanie wymaga przywilejów superu¿ytkownika.
    W ten sposób u¿ytkownik nie mo¿e wprowadziæ 'brzydkiego' programu.
	Zdarza siê, ¿e niektórym u¿ytkownikom nale¿y udostêpniæ napêd
    dyskietek, istnieje na to kilka sposobów:

	<itemizedlist>

	<listitem><para> Daæ im has³o roota. Oczywi¶cie stanowi to
    zagro¿enie bezpieczeñstwa systemu, ale jest na³atwiejszym wyj¶ciem.
	Jest to dobre wyj¶cie na domowych komputerach.
	</para></listitem>

	<listitem><para> Skorzystaæ z programu <command>sudo</command> aby umo¿liwiæ
    u¿ytkownikom uruchamianie programu mount. Ci±gle jest dziura w bezpieczeñstwie,
    choæ nie daje bezpo¶redniego dostêpu do roota.
		<footnote><para> Musisz zastanowiæ siê móg³by¶ zrobiæ bêd±c
        u¿ytkownikiem.
		</para></footnote>
	</para></listitem>
	
	<listitem><para> Pozwoliæ u¿ytkownikom korzystaæ z pakietu
    <command>mtools</command>(programy manipuluj±ce dyskietkami
    MS-DOS bez potrzeby montowania).
	</para></listitem>

	<listitem><para> Wstawiæ odpowiednie wpisy do pliku
	<filename>/etc/fstab</filename>.</para></listitem>

	</itemizedlist>

	Ostatnia alternatywa mo¿e zostaæ zaimplementowana poprzez wstawienie
    nastêpuj±cej linijki do pliku <filename>/etc/fstab</filename>:

<screen>
/dev/fd0            /floppy      msdos   user,noauto      0     0
</screen>

	Kolumny oznaczaj±: plik urz±dzenia, punkt montowania, typ systemu plików,
    opcje, czêstotliwo¶æ tworzenia kopii bezpieczeñstwa
    (u¿ywane przez <command>dump</command>) i numer dla <command>fsck</command>
    oznaczaj±cy kolejno¶æ sprawdzania (aby podaæ kolejno¶æ sprawdzania,
    0 oznacza jego brak).
	</para>

	<para> Opcja <option>noauto</option> powstrzymuje mount od automatycznego
    montowania podczas startu systemu (wykonywania 
	<command>mount -a</command>).  Opcja <option>user</option> 
    oznacza, ¿e ka¿dy u¿ytkownik ma prawo zamontowaæ system plików
    oraz, ¿e u¿ytkownik nie ma prawa uruchamiaæ programów znajduj±cych
    siê na tym systemie plików, oraz wy³±cza interpretacje plików urz±dzeñ.
	Po takich zmianach ka¿dy u¿ytkownik mo¿e zamontowaæ dyskietkê
    zawieraj±c± system plików FAT:

<screen>
<prompt>$</prompt> <userinput>mount /floppy</userinput>
<prompt>$</prompt>
</screen>

	Dyskietka musi zostaæ odmontowana za pomoc± polecenia
	<command>umount</command>.</para>

	<para> Je¿eli chcesz udostêpniæ mo¿liwo¶æ korzystania z dyskietek
    ró¿nych typów musisz wstawiæ odpowiednie linijki, oraz
    stworzyæ kilka puntków montowania.
	Dla przyk³adu:

<screen>
/dev/fd0    /mnt/dosfloppy    msdos   user,noauto  0  0
/dev/fd0    /mnt/ext2floppy   ext2    user,noauto  0  0
</screen>

	Dla systemu plików MS-DOS-a zapewne chcesz zablokowaæ pozosta³ym
    dostêp do dyskietki - umo¿liwia to po³±czenie opcji:
	<option>uid</option>, <option>gid</option> i <option>umask</option>
    (wiêcej znajduje siê w podrêczniku dotycz±cym <command>mount</command>).
	Je¿eli jeste¶ nieostro¿ny, zamontowanie takiej dyskietki
    umo¿liwi skorzystanie z niej ka¿demu, co nie jest dobrym pomys³em.
	</para>

</sect2>

<sect2>
<title>Sprawdzanie integralno¶ci systemu plików za pomoc± <command>fsck</command></title>

	<para> Systemy plików to z³o¿one stworzonka i jako takie maj± 
    sk³onno¶ci do psucia siê. Poprawno¶æ systemu plików mo¿na sprawdziæ
    za pomoc± programu <command>fsck</command>.
	Mo¿na go ustawiæ tak aby naprawia³ automatycznie drobne b³êdy,
    oraz powiadamia³ u¿ytkownika w przypadku nienaprawialnych usterek.
    Na szczê¶cie, kod implementuj±cy systemy plików by³ bacznie
    sprawdzany, przez to wiêkszo¶æ b³êdów powstaje z powodu u¿ytkownika
    (niepoprawne zamkniêcie systemu), sprzêtu lub wypadki losowe
    (problemy z zasilaniem).
    </para>

	<para> Wiêkszo¶æ systemów ma ustawione automatyczne uruchamianie
    <command>fsck</command> w czasie startu, dziêki czemu
    wykryte b³êdy s± naprawiane przed u¿ycie systemu plików.
    Pamiêtaj, ¿e u¿ywanie zepsutego systemu plików najczê¶ciej
    powoduje powstanie nowych b³êdów.
	Poniewa¿ sprawdzanie du¿ego systemu plików mo¿e zaj±æ
    <command>fsck</command> du¿o czasu stosuje siê pewne sztuczki.
	Po piewsze, je¿eli instnieje plik <filename>/etc/fastboot</filename>
    sprawdzanie zostanie pominiête. Po drugie, ext2 posiada specjalne
    pole w superbloku mówi±ce czy dany system plików zosta³ poprawnie
    odmontowany. To umo¿liwia <command>e2fsck</command> (odmianie <command>fsck</command>
	dla systemu plików ext2) pomin±æ sprawdzanie poprawnie odmontowanych
    (zak³ada siê, ¿e poprawnie odmontowany system plików nie powinien
    zawieraæ b³êdów). Trik z <filename>/etc/fastboot</filename>
    opiera siê na dzia³aniu skryptów startowych.
	</para>

	<para> Automatyczne sprawdzanie dzia³a tylko dla systemów automatycznie
    montowanych podczas startu.
	Aby sprawdziæ inne musisz rêcznie uruchomiæ <command>fsck</command>.
	</para>

	<para> Je¿eli <command>fsck</command> znajdzie nienaprawialne b³êdy
    potrzebujesz g³êbokiej wiedzy o systemie plików, lub dobrej kopii 
    zapasowej. Druga opcja wydaje siê byæ ³atwiejsza (za to nudna),
    pierwsza natomiast wymaga dobrego znajomego, grupy dyskusyjnej (lub
    listy), lub innego ¼ród³a informacji je¿eli nie wiesz jak siê
    do tego zabraæ. Chcia³bym o tym napisaæ wiêcej jednak brakuje mi
    wiedzy i do¶wiadczenia, program	<command>debugfs</command> mo¿e
    okazaæ siê po¿yteczny.</para>

	<para> Za pomoc± <command>fsck</command> powiniene¶ sprawdzaæ tylko odmontowane systemy plików (wyj±tkiem jest sprawdzanie zmontowanego w trybie
tylko-do-odczytu g³ównego systemu plików). Jest to spowodowane tym, ¿e program
modyfikuje system plików bezpo¶rednio, bez wiedzy systemu operacyjnego.
</para>
	
</sect2>

<sect2>
<title>Sprawdzanie b³êdów dysku za pomoc± <command>badblocks</command></title>

	<para> Dobrym pomys³em jest okresowe uruchamianie <command>badblocks</command>
	Program wy¶wietla listê bloków, które uzna³ za zepsute.
    Tak± listê mo¿na przekazaæ programowi
	<command>fsck</command>, który zapisze odpowiednie informacje
    w strukturze systemu plików.
	Nastêpuj±cy przyk³ad ukazuje sposób wykonania:

<screen>
<prompt>$</prompt> <userinput>badblocks /dev/fd0H1440 1440 &gt; bad-blocks</userinput>
<prompt>$</prompt> <userinput>fsck -t ext2 -l bad-blocks /dev/fd0H1440</userinput>
<computeroutput>Parallelizing fsck version 0.5a (5-Apr-94)
e2fsck 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Check reference counts.
Pass 5: Checking group summary information.

/dev/fd0H1440: ***** FILE SYSTEM WAS MODIFIED *****
/dev/fd0H1440: 11/360 files, 63/1440 blocks</computeroutput>
<prompt>$</prompt>
</screen>

	Je¿eli badblocks wypisa³ blok, który by³ w u¿yciu
	<command>e2fsck</command> spróbuje przenie¶æ go w inne
    miejsce. Je¿eli blok by³ powa¿nie uszkodzony zawarto¶æ pliku
    mog³a ulec zniszczeniu.
	</para>

</sect2>

<sect2>
<title>Zwalczanie fragmentacji</title>

	<para> Podczas zapisu pliku na dysku czêsto zdarza siê, ¿e
    nie mo¿na go zapisaæ w jednym miejscu. Plik, który nie jest
    przechowywany w kolejnych blokach nazywa siê
	<glossterm>sfragmentowanym</glossterm>. Odczytanie takiego pliku
    trwa d³u¿ej poniewa¿ g³owica musi przemie¶ciæ siê wiêcej razy.
	Po¿±danym jest unikniêcie fragmentacji, chocia¿ na systemach
    z dobrym buforowaniem i czytaniem z wyprzedzeniem nie stanowi
    to du¿ego problemu.
	</para>

	<para> Algorytmy obs³uguj±ce system plików staraj± siê zapobiegaæ
    fragmentacji - poprzez trzymanie bloków nale¿±cych do tego
    samego pliku najbli¿ej jak siê da.
    Dlatego zazwyczaj nie ma potrzeby defragmentowania systemu plików,
    jednak¿e istniej± programu do tego s³u¿±ce, jednym z nich
    jest <command>e2defrag</command>, wiêcej informacji powinno znajdowaæ
    siê w dokumentacji dotycz±cej ext2.
	</para>

	<para> Istnieje wiele programów defragmentuj±cych system plików FAT.
    Aby zdefragmentowaæ system plików bez odpowiedniego programu
    powiniene¶ stworzyæ kopiê zapasow± systemu plików, stworzyæ nowy,
    po czym odtworzyæ dane z kopii zapasowej. Dobrze jest tworzyæ kopie
    zapasowe przed defragmentacj± - nie wiadomo czy co¶ nie pójdzie ¼le.
	</para>

</sect2>

<sect2>
<title>Inne programy dla wszystkich systemów plików</title>

	<para> Istnieje wiele przydatnych poleceñ.
	<command>df</command> pokazuje ilo¶æ wolnego miejsca na 
    jednym lub kilku systemach plików; <command>du</command> 
    pokazuje ile dysku zajmuje zawarto¶æ katalogu.
	</para>

	<para> <command>sync</command> wymusza zapisanie buforowanych
    danych (zobacz <xref linkend="buffer-cache"/>).  
    Zazwyczaj nie trzeba go rêcznie uruchamiaæ -
	demon <command>update</command> robi to automatycznie.
	Program mo¿e byæ przydatny po katastrofie, w której
    poleg³ <command>update</command>, lub jego pomocnik <command>bdflush</command>,
    lub w sytuacji gdy musisz <emphasis>natychmiast</emphasis> wy³±czyæ komputer i nie mo¿esz
    czekaæ na wywo³anie <command>update</command>.</para>

</sect2>

<sect2>
<title>Inne narzêdzia dla ext2</title>

	<para> <command>tune2fs</command> zmienia ustawienia systemu plików.
    Kilka najbardziej interesuj±cych opcji: 

	<itemizedlist>
	
	<listitem><para> 
	Maxymalna liczba montowañ.  <command>e2fsck</command> wymusza sprawdzenie
    dysku po okre¶lonej liczbie montowañ. W systemie s³u¿±cym jako
    maszyna testowa dobrym pomys³em mo¿e byæ zredukowanie tego limitu.
	</para></listitem>
	
	<listitem><para> 
	Maxymalny okres miêdzy sprawdzeniami. <command>e2fsck</command> 
    wymusza sprawdzenie je¿eli czas ten zosta³ przekroczony.
	Mo¿na wy³±czyæ.
    </para></listitem>
	
	<listitem><para> 
	Liczba bloków zarezerwowanych dla roota. Ext2 rezerwuje trochê
    bloków dla roota - zape³nienie dysku przez u¿ytkowników nie uniemo¿liwia
    rootowi jego pracy. Domy¶lnie 5 procent powierzchni systemu plików
    zarezerwowane jest dla roota. Na dyskietkach nie ma sensu rezerwowaæ
    miejsca dla roota.
	</para></listitem>

	</itemizedlist>
	
	Zobacz stronê podrêcznika dotycz±c± <command>tune2fs</command>.</para>

	<para> <command>dumpe2fs</command> pokazuje informacje o
    systemie plików ext2, wiêkszo¶æ z nich odczytana zostaje z superbloku.
	<xref linkend="dumpe2fs-output"/> zawiera przyk³adowe wyj¶cie programu.
    Niektóre informacje s± techniczne i wymagaj± zrozumienia sposobu
    dzia³ania systemu plików (zobacz dodatek XXX ext2fspaper), jednak
    wiêkszo¶æ jest zrozumia³a dla ka¿dego (nawet adminlamera ;-).
	</para>

<figure id="dumpe2fs-output" float="1">
<title>Przyk³adowe wyj¶cie programu <command>dumpe2fs</command></title>

<literallayout>
dumpe2fs 0.5b, 11-Mar-95 for EXT2 FS 0.5a, 94/10/23
Filesystem magic number:  0xEF53
Filesystem state:         clean
Errors behavior:          Continue
Inode count:              360
Block count:              1440
Reserved block count:     72
Free blocks:              1133
Free inodes:              326
First block:              1
Block size:               1024
Fragment size:            1024
Blocks per group:         8192
Fragments per group:      8192
Inodes per group:         360
Last mount time:          Tue Aug  8 01:52:52 1995
Last write time:          Tue Aug  8 01:53:28 1995
Mount count:              3
Maximum mount count:      20
Last checked:             Tue Aug  8 01:06:31 1995
Check interval:           0
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)

Group 0:
  Block bitmap at 3, Inode bitmap at 4, Inode table at 5
  1133 free blocks, 326 free inodes, 2 directories
  Free blocks: 307-1439
  Free inodes: 35-360
</literallayout>
</figure>

	<para> <command>debugfs</command> jest odpluskwiaczem systemu plików.
	Umo¿liwia bezpo¶redni dostêp do struktur danych tworz±cych
    system plików, przez co umo¿liwia naprawienie systemu plików w sytuacji
    nienaprawialnej przez <command>fsck</command>.
	Niektórzy u¿ywaj± tego programu do odkasowywania plików.
	<command>debugfs</command> wymaga aby¶ wiedzia³ co robisz; w innym
    wypadku mo¿esz sobie zrobiæ kuku.
	</para>

	<para> <command>dump</command> i <command>restore</command> 
    mog± zostaæ u¿yte do utworzenia kopii zapasowej i odtworzenia systemu
    plików. S± to standardowe wersje znane z innych Unixów przeznaczone
    do wspó³pracy z ext2.
	Zobacz <xref linkend="backups"/>.</para>

</sect2>

</sect1>

<sect1>
<title>Dyski bez systemu plików</title>

	<para> Nie wszystkie dyski, lub partycje u¿ywane s± jako systemy plików.
    Partycja swapu nie posiada systemu plików.
    Wiele dyskietek u¿ywanych w trybie emulacji ta¶my u¿ywanym
    przez <command>tar</command> zawiera tylko zawarto¶æ pliku, bez
    ¿adnych dodatkowych informacji.
	Dyskietki bootuj±ce Linuxa posiadaj± obraz j±dra i nic poza nim.
	</para>

	<para> U¿ywanie medium bez systemu plików zwiêksza jego pojemno¶æ.
    Zwiêksza kompatybilno¶æ z innymi systemami, np.: format tworzony
    przez <command>tar</command> jest taki sam dla wszystkich
    systemów operacyjnych, natomiast systemy plików mog± ró¿niæ miêdzy sob±.
    W razie potrzeby szybko siê przyzwyczaisz do takich dysków.
    Bootowalne dyskietki Linuxa nie musz± zawieraæ systemu plików, choæ
    jest to mo¿liwe.
	</para>

	<para> Kopiowanie zawarto¶ci dysku bez po¶rednictwa systemu plików jest
    bardzo przydatne je¿eli dosz³o do uszkodzenia systemu plików.
    Po stworzeniu kopii mo¿esz na ró¿ne sposoby próbowaæ odratowaæ
    dane, a w przypadku nie udanej próby zacz±æ od nowa.
	Mo¿na to osi±gn±æ za pomoc± <command>dd</command>:

<screen>
<prompt>$</prompt> <userinput>dd if=/dev/fd0H1440 of=floppy-image</userinput>
<computeroutput>2880+0 records in
2880+0 records out</computeroutput>
<prompt>$</prompt> <userinput>dd if=floppy-image of=/dev/fd0H1440</userinput>
<computeroutput>2880+0 records in
2880+0 records out</computeroutput>
<prompt>$</prompt>
</screen>

	Pierwsze wywo³anie tworzy dok³adn± kopiê dyskietki, zapisuje j± w pliku
	<filename>floppy-image</filename>, drugie zapisuje zachowany obraz na
    dyskietce (u¿ytkownik powinien zamieniæ dyskietkê przed drugim poleceniem -
    inaczej polecenie stanie siê bezsensowne).
	</para>

</sect1>

<sect1>
<title>Allokowanie przestrzeni dyskowej</title>

<sect2>
<title>Schemat partycjonowania</title>

	<para> Bardzo trudno jest dokonaæ optymalnego podzia³u.
    Gorzej - nie istnieje ogólna metoda - za du¿o czynników 
    nale¿y braæ pod uwagê.
	</para>

	<para> Tradycyjnie nale¿y mieæ ma³y g³ówny system plików, który zawiera³
    bêdzie <filename>/bin</filename>, <filename>/etc</filename>, <filename>/dev</filename>,
	<filename>/lib</filename>, <filename>/tmp</filename> i inne
    potrzebne do startu rzeczy. Podzia³ taki powoduje, ¿e g³ówny system
    plików jest w mniejszym stopniu nara¿ony podczas padu
    systemu, umo¿liwia szybsze i ³atwiejsze naprawienie wszelkich
    b³êdów wywo³anych katastrof±. Dla katalogów:
	<filename>/usr</filename>, <filename>/home</filename>, oraz
    swapu tworzysz osobne partycje, lub u¿ywasz osobnych dysków.
    Dziêki temu tworzenie kopii zapasowych staje siê ³atwiejsze.
    Czasami mo¿na uczyniæ katalog <filename>/usr</filename> dzielonym
    poprzez sieæ i dziêki temu zaoszczêdziæ powierzchniê dysków stacji
    roboczych.
	</para>

	<para> Podzia³ dysku na wiele partycji powoduje, ¿e wolne miejsce
    rozbite zostaje na ma³e, zale¿ne od dysku, obszary.
    Aktualnie, dyski i systemy operacyjne dzia³aj± pewnie, wiêc
    w wiêkszo¶ci wypadków wystarczy jedna partycja, taki podzia³
    czyni tworzenie kopii zapasowych (i ich u¿ywanie w razie potrzeby) 
    mniej bolesnym.
	</para>
	
<!--
%	\meta more reasons for many partitions: users/temp files/spools
%	can't fill up all disks, readonly partitions less likely to corrupt, 
%	fsck is faster, limits losses a filesystem goes really wrong,
%	logging must not be disturbed, boots from >1023 cylinders do not
%	work on all BIOS's, /usr/local won't be disturbed by an upgrade,
%	easy to divide backup on many tapes, spare (scratch) partition for
%	experimentation (e.g., a new Linux distribution), scratch can
%	also be used to backup root during upgrades
-->

	<para> W przypadku ma³ych dysków (zak³adaj±c, ¿e nie modyfikujesz j±dra)
    najlepszym wyj¶ciem pozostaje utworzenie jednej partycji.
    Natomiast posiadacze du¿ych dysków powinny utworzyæ kilka partycji.
	(Zauwa¿, ¿e s³owa "ma³y" i "du¿y" u¿ywane s± w znaczeniu relatywnym,
    twoje potrzeby decyduj± o ich dok³adnym znaczeniu).
	</para>

	<para> Dobrym pomys³em jest bycie przygotowanym na eksperymentowanie
    i zmiany w razie potrzeby (nie tylko przy instalacji, ale w pó¼niejszym
    okresie). Wymaga to odrobiny pracy, kilku reinstalacji systemu,
    ale tylko w ten sposób dojdziesz do optymalnego podzia³u.
	</para>

</sect2>

<sect2>
<title>Wymagana przestrzeñ</title>

	<para> Instalator dystrybucji powinien dostarczyæ Ci pewnych informacji
    na temat ilo¶ci wymaganego miejsca, powiniene¶ my¶leæ równie¿
    o przysz³o¶ci - zaallokowaæ odpowiednio wiêcej miejsca.
	</para>

	<para> Ilo¶æ wymaganego miejsca zale¿y od przeznaczenia komputera.
    Np. u¿ytkownik, który wykorzystuje komputer jako prost± maszynê do pisania
    zadowoli siê kilkoma megabajtami, natomiast chc±c wykorzystaæ komputer
    do sk³adu textu (za pomoc± Tex-u) nale¿y zallokowaæ du¿o wiêcej miejsca.
	</para>

	<para> A propos, podczas porównywania rozmiarów plików i dysków nale¿y
    uwa¿aæ, gdy¿ niektórzy producenci dysków jako podstawê liczenia przyjmuj±
    1000 - 1000 bajtów to dla nich 1k, itd., co jest sprzeczne z przyjêtymi
    zasadami - 1024 bajtów daje 1k, itd. Dlatego czasem mo¿e zabrakn±æ 
    kilkunastu megabajtów.
		
        <footnote><para> Sic transit discus mundi.</para></footnote>
	</para>

	<para> Allokacja miejsca dla partycji swap zosta³a omówiona w <xref
	linkend="swap-allocation"/>.</para>

</sect2>

<sect2>
<title>Przyk³adowe konfiguracje</title>

	<para> Mia³em kiedy¶ dysk o pojemno¶ci 109 MB. Aktualnie u¿ywam dysku
    o pojemno¶ci 330 MB. Wyt³umaczê jak i dlaczego podzieli³em te dyski.
	</para>

	<para> Dysk 109 MB dzieli³em na wiele ró¿nych sposobów, zale¿nie od
    potrzeb. Wyt³umaczê dwa typowe podzia³y. Pierwszy: MS-DOS razem
    z Linuxem. Czê¶æ dla DOS-a zajmowa³a 20 MB, zawiera³a kompilator
    C, edytor, kilka narzêdzi, program, na którym pracowa³em, oraz
    trochê wolnego miejsca aby zmie¶ciæ wyniki. Dla Linuxa przeznaczy³em:
    10 MB na swap, resztê (79 MB) na jedn± partycjê.
    Eksperymentowa³em z rozdzieleniem g³ównego systemu plików, <filename>/usr</filename>
    i <filename>/home</filename> na kilka partycji, jednak nigdy
    nie mia³em wystarczaj±cej ilo¶ci miejsca aby zrobiæ co¶ ciekawego.
	</para>

	<para> Gdy przesta³em potrzebowaæ MS-DOS-a, przepartycjonowa³em dysk
    tak, ¿e 12 MB zajmowa³ swap, resztê miejsca zu¿ywa³a jedna partycja
    dla Linuxa.
	</para>

	<para> Dysk 330 MB podzieli³em na kilka partycji w nastêpuj±cy sposób:

		<informaltable>
		<tgroup cols="2">
		<tbody>
		<row> <entry>5 MB</entry> <entry>g³ówny system plików</entry> </row>
	 	<row> <entry> 10 MB</entry> <entry>swap</entry> </row>
		<row> <entry>180 MB</entry> <entry><filename>/usr</filename></entry> </row>
		<row> <entry>120 MB</entry> <entry><filename>/home</filename></entry> </row>
	 	<row> <entry> 15 MB</entry> <entry>pusta partycja</entry> </row>
		</tbody>
		</tgroup>
		</informaltable>

	Pusta partycja u¿ywana by³a do testowania rzeczy wymagaj±cych jej -
    ró¿nych dystrybucji Linuxa, porównywania wydajno¶ci ró¿nych
    systemów plików, itp. W czasie pomiêdzy testami s³u¿y³a jako druga 
    partycja swap.
	</para>

</sect2>

<sect2>
<title>Dodawanie nowych dysków</title>

	<para> Dodanie nowego dysku nie nastrêcza ¿adnych problemów, oprócz
    poprawnej konfiguracji sprzêtu. Formatujesz dysk (je¿eli musisz),
    tworzysz partycje, systemy plików, dodajesz odpowiednie wpisy
    w <filename>/etc/fstab</filename> i po k³opocie.</para>

</sect2>

<sect2>
<title>Jak oszczêdaæ powierzchniê dysków</title>

	<para> Najwa¿niejsze jest aby nie instalowaæ niepotrzebnych 
    programów. Niektóre z pakietów da siê okroiæ do danych potrzeb.
    </para>

	<para> Je¿eli nie mo¿esz odinstalowaæ programu rozwi±zaniem
    mo¿e byæ kompresja. Programami do tego s³u¿±cymi s± np.:
    <command>gzip</command>, <command>zip</command>, <command>bzip2</command>.
    Program <command>gzexe</command> umo¿liwia kompresjê programów i ich
    automatyczn± dekompresjê w razie potrzeby.
    System DouBle (w fazie tworzenia) kompresuje wszystkie pliki na
    danym systemie plików, czyni to w sposób niewidzialny dla u¿ytkownika.
	(podstawa dzia³ania jest taka sama jak w programie Stacker dla MS-DOS)
	</para>

</sect2>

</sect1>

</chapter>


<chapter id="memory-management">
<title>Zarz±dzanie pamiêci±</title>

	<blockquote><para> <quote>Minnet, jag har tappat mitt minne,
	är jag svensk eller finne, kommer inte ihåg...</quote>
	(Bosse Österberg)
	</para></blockquote>

	<para> Sekcja opisuje zarz±dzanie pamiêci± w Linuksie, m.in. 
    pamiêæ wirtualn± i system buforowania urz±dzeñ blokowych.
	</para>
	
<sect1>
<title>Czym jest pamiêæ wirtualna?</title>

	<para> Linux obs³uguje <glossterm>pamiêæ wirtualn±</glossterm> -
    wykorzystuje cze¶æ dysku jako rozszerzenie fizycznej pamiêci.
    J±dro zapisuje zawarto¶æ nieu¿ywanych bloków pamiêci fizycznej
    na dysku, umo¿liwiaj±c tym samym wykorzystanie ich do innych celów.
    Je¿eli oryginalna zawarto¶æ jest potrzebna nastêpuje proces odwrotny.
    Wszystko to odbywa siê niewidocznie dla u¿ytkownika;
    dzia³aj±ce programy równie¿ nie dostrzegaj± ró¿nicy. Oczywi¶cie
    operacje dyskowe s± znacznie wolniejsze (tysi±ce razy) ni¿
    analogiczne dzia³ania na fizycznej pamiêci, programy zwalniaj±.
    Czê¶æ dysku twardego wykorzystywana jako pamiêæ wirtualna
    nosi nazwê <glossterm>obszaru wymiany</glossterm>.</para>

	<para> Linux potrafi wykorzystywaæ zwyk³y plik na systemie plików,
    lub oddzieln± partycjê jako obszar wymiany. Partycja wymiany jest
    szybsza, jednak trudniej zmieniæ jej rozmiar, ni¿ w wypadku pliku.
    Mo¿esz w celach testowych stworzyæ plik wymiany, a gdy ju¿ bêdziesz
    pewnien co do potrzebnego rozmiaru stworzyæ osobn± partycjê.
	</para>

	<para> Powiniene¶ wiedzieæ, ¿e Linux pozwala u¿ywaæ
    kilku partycji/plików wymiany jednocze¶nie. Dziêki temu mo¿esz
    dynamicznie regulowaæ wielko¶æ swapu, np. stworzyæ partycjê 
    o odpowiednim rozmiarze (takim aby siê nie marnowa³a), a przy
    specjalnych okazjach wykorzystywaæ dodatkow± partycjê/plik, itp.
	</para>
	
	<para> Krótka lekcja terminologii komputerowej:
    komputerowi naukowcy najczê¶ciej rozró¿niaj± 
    swapowanie (zapisywanie ca³ego procesu na dysku) od
    stronicowania (zapisywanie czê¶ci o sta³ym rozmiarze,
    zazwyczaj kilku kilobajtów). Stronicowanie jest zazwyczaj szybsze,
    dlatego Linux go u¿ywa, pomimo tego tradycyjna terminiologia Linuxa
    mówi o swapowaniu.
	
		<footnote><para> 
        Zatem ca³kiem niepotrzebnie denerwuj±ca rzesza komputerowych
        naukowców jest straszna.
		</para></footnote>
	</para>

</sect1>

<sect1>
<title>Tworzenie obszaru wymiany</title>

	<para> J±dro postrzega swap jako normalny plik, liczy siê jedynie
    brak dziur i specjalna sygnatura utworzona za pomoc± 
	<command>mkswap</command>. Plik musi znajdowaæ siê na lokalnym
    systemie plików, NFS nie wchodzi w grê.
	</para>

	<para> Informacja o dziurach jest wa¿na. Plik wymiany powinien
    mieæ zarezerwowan± objêto¶æ, tak aby j±dro zapisuj±c dane nie musia³o
    allokowaæ sektorów dla pliku. Dziura w pliku oznacza, ¿e nie ma
    zaallokowanych sektorów, a to powoduje drastyczny spadek wydajno¶ci.
	</para>

	<para> Dobrym sposobem na utworzenie odpowiedniego pliku wymiany
    jest nastêpuj±ce polecenie:

<screen>
<prompt>$</prompt> <userinput>dd if=/dev/zero of=/extra-swap bs=1024 count=1024</userinput>
<computeroutput>1024+0 records in
1024+0 records out</computeroutput>
<prompt>$</prompt>
</screen>
    gdzie <filename>/extra-swap</filename> jest nazw± pliku wymiany,
    rozmiar pliku podawany jest za pomoc± opcji <literal>count=</literal>.
	Rozmiar powinien byæ podzielny przez 4 - j±dro zapisuje 
	<glossterm>strony pamiêci</glossterm> w blokach po 4 kB.
	</para>

	<para> Partycja wymiany nie jest niczym specjalnym. Tworzysz
    j± jak normaln± partycjê, jedyn± ró¿nic± jest to, ¿e
    nie zawiera systemu plików. Dobrym pomys³em jest ustawienie typu
    partycji na 82 (Linux Swap), dziêki temu lista partycji stanie siê
    czytelniejsza.
	</para>

	<para> Po stworzeniu pliku lub partycji musisz stworzyæ odpowiedni±
    sygnaturê. S³u¿y do tego <command>mkswap</command>, np.:

<screen>
<prompt>$</prompt> <userinput>mkswap /extra-swap 1024</userinput>
<computeroutput>Setting up swapspace, size = 1044480 bytes</computeroutput>
<prompt>$</prompt>
</screen>

	Zauwa¿, ¿e taki obszar wymiany nie zostanie u¿yty - instnieje, jednak
    j±dro o nim nic nie wie.
	</para>
	
	<para> Pos³uguj±c siê <command>mkswap</command> powiniene¶ byæ
    ostro¿ny - program nie wykonuje ¿adnych testów przed stworzeniem
    sygnatury.
	<emphasis>Mo¿e ³atwo nadpisaæ wa¿ne dane za pomoc± 
	<command>mkswap</command>!</emphasis></para>

	<para> Mechanizm zarz±dzania pamiêci± limituje rozmiar pojedynczego
    obszaru wymiany do 127 MB, oraz mo¿e ich byæ maxymalnie 8 (co daje 1 GB).
    (przyp. t³um.: w której¶ wersji j±dra usuniêto ten limit, nie pamiêtam w której).

		<footnote><para> Gigabajt w t±, gigabajt we wt±, nied³ugo rzeczywista
        pamiêæ bêdzie mia³a tak± pojemno¶æ.
		</para></footnote>

	</para>

</sect1>

<sect1>
<title>U¿ywanie obszaru wymiany</title>

	<para> Zainicjowany swap nale¿y aktywowaæ za pomoc± 
	<command>swapon</command>. Program ten powiadamia j±dro, ¿e mo¿na
    u¿ywaæ tego obszaru jako swap. Nasz plik wymiany mo¿emy aktywowaæ
    za pomoc± takiego polecenia:

<screen>
<prompt>$</prompt> <userinput>swapon /extra-swap</userinput>
<prompt>$</prompt>
</screen>

	Obszary wymiany mo¿na aktywowaæ automatycznie - wystarcz± odpowiednie
    wpisy w <filename>/etc/fstab</filename>:

<screen>
/dev/hda8        none        swap        sw     0     0
/swapfile        none        swap        sw     0     0
</screen>

	Skrypty startowe wywo³uj± <command>swapon -a</command> co powoduje
    aktywacjê wszystkich obszarów wymiany wyliczonych w 
	<command>/etc/fstab</command>. 
	</para>
	
	<para> Wykorzystanie swapu mo¿esz nadzorowaæ za pomoc±  programu
	<command>free</command>, który wypisze aktualne zu¿ycie pamiêci:

<screen>
<prompt>$</prompt> <userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers
Mem:         15152      14896        256      12404       2528
-/+ buffers:            12368       2784
Swap:        32452       6684      25768</computeroutput>
<prompt>$</prompt>
</screen>

	Pierwsza linia (<literal>Mem:</literal>) zawiera ilo¶æ fizycznej
    pamiêci. Kolumna total pokazuje pamiêæ dostêpn± dla systemu (ilo¶æ
    fizycznej pamiêci odj±æ pamiêæ wykorzystywan± przez j±dro).

	Kolumna used pokazuje ilo¶æ pamiêci aktualnie wykorzystywanej
    (druga linia odlicza bufory). Kolumna free pokazuje ca³kowicie
    nie u¿ywan± pamiêæ. Kolumna shared pokazuje ilo¶æ pamiêci dzielonej
    przez kilka procesów. Kolumna buffers pokazuje aktualny rozmiar
    buforów dla operacji na urz±dzeniach blokowych.
    </para>
	
	<para> Ostatnia linia (<literal>Swap:</literal>) pokazuje podobne
    informacje odno¶nie obszarów wymiany. Je¿eli linia zawiera same
    zera swap nie zosta³ aktywowany.
	</para>
	
	<para> Te same informacje dostêpne s± via
	<command>top</command>, <filename>/proc/meminfo</filename>.  
    Aby otrzymaæ informacje odno¶nie wykorzystania poszczególnych
    obszarów swap zajrzyj do pliku <filename>/proc/swaps</filename>.
	</para>

	<para> Obszar wymiany mo¿na wy³±czyæ za pomoc± 
	<command>swapoff</command>. Wszelkie dane zapisane na danym
    swapie s± najpierw wczytywane do pamiêci, je¿eli nie ma miejsca
    zostaj± wypisane na inne miejsce. Je¿eli brakuje wirtualnej pamiêci
    Linux zacznie d³awiæ siê; po do¶æ d³ugim okresie powinien wyj¶æ z 
    tego, w miêdzyczasie system bêdzie bezu¿yteczny, dlatego
    przed wy³±czeniem obszaru wymiany powiniene¶ sprawdziæ czy istnieje
    wystarczaj±ca ilo¶æ nieu¿ywanej pamiêci.
	</para>

	<para> Wszystkie obszary wymiany s± automatycznie aktywowane za
    pomoc± <command>swapon -a</command>, deaktywowane przy pomocy
    <command>swapoff -a</command>; informacje o obszarach wymiany
    pobierane s± z pliku
	<filename>/etc/fstab</filename>. Wszystkie rêcznie aktywowane 
    obszary zostan± w u¿ycie.</para>

	<para> Czasami swap jest u¿ywany pomimo wolnej pamiêci. Dzieje siê
    tak po usuniêciu pamiêcio¿ernego procesu. Dane znajduj±ce
    siê w swapie nie zostan± za³adowane a¿ do ¿±dania ich.
    W ten sposób zmniejsza siê ilo¶æ operacji dyskowych i przy¶piesza
    pracê systemu - nastêpny program mo¿na szybko uruchomiæ, gdy¿
    istnieje nie u¿ywana pamiêæ. Nie powiniene¶ siê tym martwiæ,
    ale powiniene¶ wiedzieæ.
	</para>

</sect1>

<sect1>
<title>Dzielenie obszaru wymiany miêdzy systemami operacyjnymi</title>

	<para> Pamiêæ wirtualna wbudowana jest w wiele systemów operacyjnych.
    Poniewa¿ jest ona potrzebna tylko w czasie ich pracy (nigdy w 
    tym samym czasie) mo¿naby j± wspó³dzieliæ. Jest to mo¿liwe,
    jednak wymaga pewnych specjalnych zabiegów. Wiêcej informacji
    znajduje siê w 
	Tips-HOWTO.</para>

</sect1>

<sect1 id="swap-allocation">
<title>Allokowanie obszaru wymiany</title>

	<para> Niektórzy twierdz±, i¿ powiniene¶ zaallokowaæ dwa razy 
    wielko¶æ ramu, nie jest to prawid³owe podej¶cie.
	Oto jak to zrobiæ poprawnie:

	<itemizedlist>

	<listitem>
	
	<para> Okre¶l ca³kowite zapotrzebowanie na pamiêæ. Jest to najwiêksza
    ilo¶æ pamiêci, któr± bêdziesz jednocze¶nie potrzebowa³,
    suma zapotrzebowañ wszystkich programów. Mo¿esz to zrobiæ uruchamiaj±c
    wszystkie programy z twojej listy. (je¿eli nie masz dostatecznej
    ilo¶ci pamiêci prawdopodobnie czê¶æ z nich siê wywali).</para>

	<para> Dla przyk³adu: je¿eli chcesz uruchamiaæ X, powiniene¶ zaallokowaæ
    dla niego oko³o 8 MB, gcc potrzebuje kilka megabajtów ( niektóre
    pliki potrzebuj± niezwykle du¿o pamiêci - oko³o 10 MB, jednak zazwyczaj
    wystarczaj± 4 MB ), itd. J±dro zu¿yje oko³o megabajta dla siebie,
    zazwyczaj pow³oka i kilka potrzebnych narzêdzi razem da nam 
    zapotrzebowanie na 1 MB. Nie musisz byæ dok³adnym, jednak powiniene¶
    podchodziæ do sprawy pesymistycznie.
	</para>
	
	<para> Pamiêtaj, ¿e nale¿y braæ równie¿ liczbê osób pracuj±cych
    na komputerze. Jednak¿e, je¿eli dwaj u¿ytkownicy uruchomi± ten sam 
    program zu¿ycie nie podwoi siê - czê¶æ programu, oraz biblioteki bêd±
    dzielone miêdzy procesami.
	</para>
	
	<para> Polecenia: <command>free</command> i <command>ps</command>
    przydadz± Ci siê do oszacowania zapotrzebowania.
	</para>
	</listitem>

	<listitem>
	<para> Podczas szacowania pamiêci w kroku 1 musisz pamiêtaæ
    o bezpiecznej granicy - prawdopodobnie zapomnisz o kilku programach,
    albo zmienisz swoje wymagania. Musisz od³o¿yæ trochê pamiêci
    na czarn± godzinê. (Lepiej zaallokowaæ zbyt du¿o ni¿ zbyt ma³o
    swapu, jednak nie ma sensu aby miejsce siê marnowa³o - musisz
    wybraæ dla siebie optimum). Poniewa¿ lepiej jest pracowaæ z okr±g³ymi
    liczbami mo¿esz zaokr±gliæ rozmiar do pe³nych megabajtów.
	</para>
	
	</listitem>
	
	<listitem>
	
	<para> Opieraj±c siê na powy¿szych obliczeniach powiniene¶
    oszacowaæ twoje potrzeby. Aby wyznaczyæ rozmiar obszaru wymiany
    powiniene¶ od obliczonej liczby odj±æ rozmiar fizycznej pamiêci.
    (Na niektórych Unixach musisz zaallokowaæ obszar licz±c równie¿
    pamiêæ fizyczn± - w tym wypadku nie odejmuj jej rozmiaru).
	</para>

	</listitem>
	
	<listitem>

	<para> Je¿eli twój wyliczony rozmiar swapu jest znacznie wiêkszy
    ni¿ twoja fizyczna pamiêæ (kilkakrotnie wiêcej) powiniene¶ zainwestowaæ
    pieni±dze w zakup wiêkszej ilo¶æ pamiêci, w innym wypadku odczujesz
    spadek wydajno¶ci.
	</para>

	</listitem>

	</itemizedlist>
    </para>

	<para> Dobrym pomys³em jest utworzenie swapu nawet je¿eli go nie potrzebujesz.
    Linux agresywnie korzysta ze swapu, tak aby jak najwiêcej
    fizycznej pamiêci by³o dostêpne. Linux zapisze na dysku wszelkie
    nie u¿ywane dane. W ten sposób mamy wiêcej pamiêci dostêpnej od
    rêki.
	</para>

	<para> Obszar wymiany mo¿e byæ rozdzielony na kilka dysków.
    W ten sposób mo¿na poprawiæ wydajno¶æ. Mo¿esz popróbowaæ kilku
    schematów, jednak pamiêtaj, ¿e robienie takich eksperymentów jest
    trudne. Nie powiniene¶ wierzyæ w wy¿szo¶æ jednego schematu nad drugim,
    zale¿y to od wielu czynników i w twoim wypadku mo¿e byæ k³amstwem.
	</para>
	
</sect1>

<sect1 id="buffer-cache">
<title>Bufor</title>

	<para> Odczytywanie dysku
	
		<footnote><para> Pomijaj±c RAM-dysk, z przyczyn oczywistych.
        </para></footnote>
		
	jest bardzo wolne w porównaniu z odczytem prawdziwej pamiêci.
    Do tego, najczê¶ciej ten sam obszar dysku odczytywany jest w
    ma³ych odstêpach czasu. Dla przyk³adu: kto¶ mo¿e odczytaæ list
    e-mail chc±c na niego odpowiedzieæ, po czym odczytaæ go ponownie
    aby przenie¶æ go do innego folderu. Lub, pomy¶l ile razy
	<command>ls</command> mo¿e zostaæ uruchomiony na systemie z wieloma
    u¿ytkownikami. Zapisywanie danych odczytanych z dysku przy¶piesza kolejne
    odwo³ania. Proces taki zwany jest <glossterm>buforowaniem dysków
	</glossterm>.
	</para>

	<para> Poniewa¿ pamiêæ jest, niestety, skoñczona bufor musi mieæ
    ograniczon± wielko¶æ (czasami nie mo¿e pomie¶ciæ na raz wymaganych
    danych). Gdy dochodzi do zape³nienia bufora dane, które nie by³y
    u¿ywane przez najd³u¿szy czas s± usuwane z bufora, powstaje miejsce
    na nowe.
	</para>

	<para> Buforowanie dysków dzia³a równie¿ dla operacji zapisu.
    Czêsto ¶wie¿o zapisane s± odczytywane ponownie, w krótkim odstêpie
    czasu (np. zmiana kodu ¼ród³owego i ponowna kompilacja).
    Dlatego umieszczanie zapisywanych danych w buforze jest dobr±
    praktyk±. Odk³adanie zapisania na dysk równie¿ przy¶piesza programy.
	</para>

	<para> Wiêkszo¶æ systemów operacyjnych posiada mechanizm
    buforowania operacji dyskowych, jednak nie wszystkie z nich dzia³aj±
    wed³ug powy¿szego opisu.
	Niektóre z nich dzia³aj± wdg zasady <glossterm>zapisuj-poprzez</glossterm>: 
    dane zapisywane s± na dysku i odk³adane w buforze. Istnieje równie¿
    metoda <glossterm>zapisz-i-powróæ</glossterm> - dane s± umieszczane
    w pamiêci, aktualizacja dysku dokonywana jest co pewien okres.
    Druga metoda jest wydajniejsza jednak czyni system bardziej podatnym na
    zdarzenia losowe - odciêcie zasilania powoduje utratê danych znajduj±cych
    siê w pamiêci, mo¿e to równie¿ doprowadziæ do uszkodzenia systemu plików -
    struktury systemu plików mog± nie zostaæ uaktualnione.
	</para>
	
	<para> Dlatego, nigdy nie powiniene¶ wy³±czaæ komputera przed
    poprawnym wykonaniem procedury wy³±czenia systemu operacyjnego
    (zobacz <xref linkend="boots-and-shutdowns"/>), oraz zmieniaæ 
    dyskietek przed ich odmontowaniem.
	Program <command>sync</command> <glossterm>flushes (opró¿nia)</glossterm>
	bufor - wymusza zapisanie wszelkich danych znajduj±cych siê w nim.
    W tradycyjnych odmianach Unixa istnieje polecenie 
	<command>update</command>, które co 30 sekund uruchamia
	<command>sync</command>, Linux posiada demona 
	<command>bdflush</command>, który wykonuje pobie¿n± synchronizacjê
    danych aby unikn±æ ogromnej ilo¶ci operacji we/wy na dysk powodowanych,
    czasami, przez <command>sync</command>.</para>
	
	<para> W Linuksie <command>bdflush</command> uruchamiany jest przez
	<command>update</command>. Je¿eli co¶ siê przydarzy <command>bdflush</command> 
    j±dro Ciê o tym poinformuje i bêdziesz musia³ rêcznie uruchomiæ opró¿nianie buforów
	(<command>/sbin/update</command>).</para>

	<para> Aktualnie buforowaniu podlegaj± bloki (nie pliki), które
    s± najmniejsza jednostk± operacji dyskowych.
	(pod Linuxem s± one zazwyczaj wielko¶ci 1 kB). Dziêki temu
    katalogi, superbloki i inne struktury systemu plików, oraz dane
    niezale¿ne od systemu plików s± buforowane.
	</para>

	<para> Efektywno¶æ bufora jest najczê¶ciej podyktowana jego rozmiarem.
    Ma³y bufor jest prawie bezu¿yteczny - dane znikn± z niego przed
    ponownym odwo³aniem siê do nich. 
	</para>

	<para> Je¿eli bufor posiada sta³y rozmiar nie powinien byæ on zbyt du¿y,
    poniewa¿ aplikacje nie bêd± mia³y miejsca do dzia³ania i bêd± musia³y
    byæ zapisywane w swapie (co jest powolnym procesem).
    Aby jak najefektywniej wykorzystaæ fizyczn± pamiêæ Linux
    automatycznie wykorzystujê wszelkie nieu¿ywane zakamarki jako
    bufor operacji blokowych, jednocze¶nie automatycznie zwalnia
    pamiêæ w przypadku zapotrzebowania na ni±.
	</para>

	<para> W Linuksie nie musisz robiæ nic aby wykorzystywaæ dobrodziejstwa
    bufora, wszystko zachodzi automatycznie. Jedyne co musisz robiæ to
    poprawnie uruchamiaæ i zamykaæ system.
    </para>
</sect1>
</chapter>

<chapter id="boots-and-shutdowns">
<title>Start i stop</title>

	<blockquote><para> <literallayout>
Start me up
Ah... you've got to... you've got to
Never, never never stop
Start it up
Ah... start it up, never, never, never
 You make a grown man cry,
  you make a grown man cry
(Rolling Stones)
</literallayout></para></blockquote>

	<para>  Sekcja wyja¶nia co siê dzieje podczas startu i zamykania Linuxa.
    Je¿eli poprawne procedury nie s± przestrzegane mo¿e doj¶æ do zniszczenia
    systemu plików i utraty danych.
	</para>
	
<sect1>
<title>Ogólne informacje</title>

	<para> Akt w³±czania komputera i ³adowania systemu operacyjnego
	
		<footnote><para> W pierwszych komputerach nie wystarczy³o w³±czyæ
        urz±dzenia, trzeba by³o rêcznie za³adowaæ system operacyjny.
	    </para></footnote>
	nazywany jest <glossterm>bootowaniem (³adowaniem)</glossterm>.
	</para>

	<para> Na pocz±tku komputer wykonuje 
    <glossterm>program ³aduj±cy</glossterm>, którego zadaniem
    jest za³adowanie i uruchomienie systemu operacyjnego. Kod ten
    zazwyczaj znajduje siê w ¶ci¶le okre¶lonym miejscu i 
    jest stosunkowo ma³y (kilkaset bajtów).
	</para>

	<para> Ró¿ne komputery maj± ró¿ne procedury startowania.
    PeCet (jego BIOS) odczytuje pierwszy sektor  
	(zwany <glossterm>sektorem ³aduj±cym</glossterm>) dyskietki, lub dysku.
    Program ³aduj±cy znajduj±cy siê w tym¿e sektorze ³aduje
    system operacyjny z innej czê¶ci dysku (lub z innego urz±dzenia).
    </para>

	<para> Po za³adowaniu Linuxa nastêpuje inicjalizacja sprzêtu i odpowiednich
    sterowników, po czym uruchomiony zostaje 
	<command>init</command>. <command>init</command> uruchamia inne
    procesy, te z kolei umo¿liwiaj± zalogowanie siê u¿ytkowników i wiele
    innych rzeczy.
    Szczegó³y zostan± omówione poni¿ej.
	</para>

	<para> W celu wy³±czenia systemu Linux nale¿y wszystkim procesom
    powiedzieæ, ¿e maj± siê zakoñczyæ (zamkn±æ wszystkie pliki i zrobiæ
    inne niezbêdne rzeczy), nastêpuje odmontowanie systemu plików i
    obszarów wymiany, po czym nastêpuje wy¶wietlenie informacji
    o mo¿liwo¶ci wy³±czenia komputera. Je¿eli prawid³owa procedura
    nie jest przestrzegana dyski mog± nie zostaæ zaktualizowane
    (dane zostaj± stracone, mo¿liwo¶æ uszkodzenia systemu plików).
	</para>

</sect1>

<sect1>
<title>Proces startowania - szczegó³y</title>

	<para> Linuxa mo¿esz uruchomiæ z kilku ró¿nych urz±dzeñ.
    Podrêcznik "Installation and Getting Started" omawia
    sposoby startowania z ró¿nych urz±dzeñ. 
	</para>

	<para> Po w³±czeniu komputera BIOS przeprowadza ró¿ne testy
	
		<footnote><para> Testy te nazywane s±
		<glossterm>power on self test (POST)</glossterm>, co oznacza
        samotestowanie siê po w³±czeniu zasilania.
		</para></footnote>
		
    po czym przechodzi do uruchamiania systemu. Wybiera odpowiedni
    dysk (wybór mo¿na skonfigurowaæ) i odczytuje jego pierwszy sektor.
    (<glossterm>sektor ³aduj±cy</glossterm>; lub w przypadku dysków 
    twardych <glossterm>g³ówny rekord ³aduj±cy</glossterm> - ka¿da
    z partycji zawiera swój sektor ³aduj±cy)</para>

	<para> Sektor ³aduj±cy zawiera niewielki program (na tyle ma³y
    aby zmie¶ci³ siê w jednym sektorze), którego zadaniem jest
    za³adowanie systemu operacyjnego z dysku. Podczas startowania
    z dyskietki zadaniem tego kodu jest wczytanie kilku bloków
    (zale¿nie od rozmiaru j±dra) pod odpowiedni adres w pamiêci.
    Zazwyczaj na dyskietce znajduje siê tylko j±dro, bez ¿adnego
    systemu plików, co upraszcza proces startowania; je¿eli na
    dyskietce znajduje siê systemem plików nale¿y u¿yæ LILO.
	</para>

	<para> Kod zawarty w g³ównym rekordzie ³aduj±cym ma utrudnione zadanie -
    musi sprawdziæ tablicê partycji i wybraæ aktywn±, odczytaæ jej
    sektor ³aduj±cy i przekazaæ mu sterowanie. Kod zawarty w sektorze
    ³aduj±cym robi to samo co odpowiednik z dyskietki. Jednak w szczegó³ach
    oba programy siê ró¿ni± - zazwyczaj nie tworzy siê osobnej partycji
    zawieraj±cej tylko j±dro, wiêc trzeba je znale¼æ na systemie
    plików. Istnieje kilka sposobów aby to zrobiæ, najpopularniejszym
    jest u¿ycie LILO.
	(Dok³adne rozwi±zanie problemu jest, w naszej dyskusji, niepotrzebne,
    gdyby¶ chcia³ poznaæ szczegó³y siêgnij do dokumentacji LILO)
	</para>

	<para> LILO najczê¶ciej odczytuje domy¶lne j±dro i uruchamia je, mo¿na
    program skonfigurowaæ tak, aby umo¿liwiæ wybór jednego z kilku,
    lub nawet innego systemu operacyjnego.
    LILO mo¿na skonfigurowaæ tak, aby reagowa³o na klawisze:
	<keycap>alt</keycap>, <keycap>shift</keycap>, lub
	<keycap>ctrl</keycap> podczas swego ³adowania, co umo¿liwi
    wybór systemu, mo¿na je równie¿ skonfigurowaæ aby domy¶lnie
    czeka³o na wybranie systemu, dodatkowo mo¿na ustaliæ okres oczekiwania,
    po którym zostanie u¿yte domy¶lne ustawienie.
	</para>
	
	<para> Za pomoc± LILO mo¿na przekazaæ j±dru argumenty.</para>

	<para> Startowanie z ka¿dego z urz±dzeñ ma swoje zalety, jak i wady,
    zasadniczo startowanie z dysku jest przyjemniejsze, poniewa¿
    nie trzeba siê bawiæ dyskietkami, a do tego jest szybsze.
    W przypadku k³opotów warto mieæ jednak dyskietkê startow± pod rêk± -
    umo¿liwi ona uruchomienie systemu po zmianie MBR, lub innym wypadku.
	</para>

	<para> Po wczytaniu j±dra Linuxa do pamiêci i uruchomieniu go dziej±
    siê nastêpuj±ce rzeczy:
	
	<itemizedlist>

	<listitem><para> 
    J±dro dekompresuje siê - najczê¶ciej instalowane jest w postaci 
    skompresowanej. Pocz±tek j±dra zawiera ma³y dekompresor, który
    tego dokonuje.
	</para></listitem>

	<listitem><para> 
    Je¿eli masz kartê super-VGA, któr± Linux rozpoznaje i która
    ma mo¿liwo¶æ zmiany trybu textowego Linux pyta siê, który z nich
    wybraæ. Podczas kompilacji j±dra ustala siê domy¶lny tryb,
	mo¿na go równie¿ ustawiæ za pomoc± LILO, lub <command>rdev</command>.
	</para></listitem>

	<listitem><para> 
	J±dro sprawdza zainstalowany sprzêt (dyski, napêdy dyskietek, karty
    sieciowe, itd.) i odpowiednio go konfiguruje; w miêdzy czasie
    wy¶wietlane s± odpowiednie informacje. Np.:
<screen>
<computeroutput>
LILO boot:
Loading linux.
Console: colour EGA+ 80x25, 8 virtual consoles
Serial driver version 3.94 with no serial options enabled
tty00 at 0x03f8 (irq = 4) is a 16450
tty01 at 0x02f8 (irq = 3) is a 16450
lp_init: lp1 exists (0), using polling driver
Memory: 7332k/8192k available (300k kernel code, 384k reserved, 176k data)
Floppy drive(s): fd0 is 1.44M, fd1 is 1.2M
Loopback device init
Warning WD8013 board not found at i/o = 280.
Math coprocessor using irq13 error reporting.
Partition check:
  hda: hda1 hda2 hda3
VFS: Mounted root (ext filesystem).
Linux version 0.99.pl9-1 (root@haven) 05/01/93 14:12:20
</computeroutput>
</screen>

	Dok³adne informacje zale¿± od j±dra i jego ustawieñ.
	</para></listitem>

	<listitem><para>  J±dro spróbuje zamontowaæ g³ówny system plików.
    Jego po³o¿enie jest konfigurowalne w czasie kompilacji; równie¿
	za pomoc± <command>rdev</command>, lub LILO. Je¿eli nie mo¿na
    tego dokonaæ j±dro panikuje i zatrzymuje system (zbyt du¿o w takiej
    sytuacji nie da siê zrobiæ).
	</para>

	<para> G³ówny system plików jest zazwyczaj montowany wy³±cznie-do-odczytu
    (mo¿na to zmieniæ tak samo jak jego po³o¿enie). Umo¿liwi to sprawdzenie
    systemu plików po jego zamontowaniu; nierozs±dnie jest sprawdzaæ
    zamontowany system plików.
	</para></listitem>

	<listitem><para> Nastêpnie j±dro uruchamia proces
	<command>init</command> (domy¶lnie z katalogu 
	<filename>/sbin/init</filename>) w tle (proces zawsze ma id = 1 ).
	<command>init</command> odpowiedzialny jest za wiele rzeczy,
    czê¶æ z nich podlega kontroli administratora; zobacz
	<xref linkend="init"/>. 
	</para></listitem>

	<listitem><para> <command>init</command> odpowiedzialny jest za uruchamianie
    programów na poszczególnych poziomach pracy, w trybach wielou¿ytkownikowych
    uruchamia <command>getty</command> na terminalach wirtualnych.
	<command>getty</command> pozwala u¿ytkownikom zalogowaæ siê do
    systemu.
	<command>init</command> zgodnie z konfiguracj± mo¿e uruchomiæ inne
    programy.
	</para></listitem>

	<listitem><para>  Proces startowania jest kompletny.
	</para></listitem>

	</itemizedlist>
    	</para>

</sect1>

<sect1>
<title>Wiêcej o zamykaniu systemu</title>

	<para> Wa¿ne jest aby poprawnie zamkn±æ system. Je¿eli tego nie
    zrobisz stracisz dane i uszkodzisz system plików. Dzieje siê tak
    dlatego, poniewa¿ Linux nie zapisuje danych od razu, robi
    to co pewien okres. Taki sposób dzia³ania znacz±co przy¶piesza
    dzia³anie programów, jednak wymaga poprawnego zamkniêcia systemu.
	</para>

	<para> Poleceniem odpowiedzialny za prawid³owe wy³±czenie Linuxa
    jest <command>shutdown</command>.
	</para>

	<para> Programowi mo¿na podaæ czas oczekiwania przed zamkniêciem, 
    umo¿liwiaj±c w ten sposób u¿ytkownikom szansê zamkniêcia programów
    i wylogowania siê. Przyk³ad:
	</para>

<screen>
<prompt>#</prompt> <userinput>shutdown -h +10 'Zainstalujemy nowy dysk. System bêdzie
> dostêpny w ci±gu 3 godzin.'
</userinput>
<prompt>#</prompt>
</screen>
	<para>
	Wiadomo¶æ zostanie wys³ana wszystkim u¿ytkownikom, je¿eli
    nie zastosuj± siê do niej mog± utraciæ dane.
    Oto jej przyk³adowa postaæ:
	</para>
<screen>
<computeroutput>
Broadcast message from root (ttyp0) Wed Aug  2 01:03:25 1995...

Zainstalujemy nowy dysk. System bêdzie
dostêpny w ci±gu 3 godzin.
The system is going DOWN for system halt in 10 minutes !!
</computeroutput>
</screen>
	<para>
	Wiadomo¶æ bêdzie powtarzana coraz czê¶ciej w miarê up³ywu czasu.
	</para>

	<para> Kiedy rozpoczyna siê prawdziwe wy³±czanie systemu wszelkie
    procesy dostaj± sygna³ SIGTERM (po pewnym odstêpie czasu SIGKILL),
    systemy plików zostaj± odmontowane (oprócz g³ównego).
	<command>init</command> wypisuje informacje o mo¿liwo¶ci wy³±czenia
    komputera. Wtedy i tylko wtedy mo¿esz wy³±czyæ zasilanie.
	</para>

	<para> Czasami, rzadko na systemach porz±dnie zarz±dzanych,
    dochodzi do sytuacji gdy co¶ nie zadzia³a. Dla przyk³adu: j±dro
    panikuje i wywala siê, wtedy mo¿esz siê jedynie modliæ aby¶ nie straci³
    zbyt wiele i wy³±czyæ zasilanie. Je¿eli zdarzy³o siê co¶ mniej
    powa¿nego (np. kto¶ ci siekier± klawiaturê rozwali³ ;-) pomy¶l
    jak mo¿esz zmusiæ system do poprawnego zamkniêcia (w tym przypadku
    logowanie przez sieæ rozwi±zuje problem), je¿eli taka mo¿liwo¶æ
    nie istnieje spróbuj od³±czyæ wszelkie zewnêtrzne bod¼ce (np.
    od³±cz sieæ, itp.), poczekaj a¿ 
	<command>update</command> kilka razy zapisze dane na dysku
    (kilka minut) po czym wy³±cz zasilanie.
	</para>

	<para> Niektórzy lubi± zamykaæ system wywo³uj±c
	<command>sync</command>
	
		<footnote><para> <command>sync</command> wymusza
        aktualizacje dysków.
		</para></footnote>
		
	trzy razy, po czym czekaj± na zakoñczenie dyskowych operacji we/wy i
    wy³±czaj± zasilanie. Je¿eli nie ma dzia³aj±cych programów
    dzia³a to, <emphasis>prawie</emphasis>, tak samo jak 
	<command>shutdown</command>.  Jednak¿e, nie nastêpuje odmontowanie
    systemu plików co powoduje, ¿e podczas nastêpnego startowania dyski zostan±
    sprawdzone.
	<emphasis>Nie zaleca siê takiego podej¶cia</emphasis>.</para>

	<para> (Je¿eli siê zastanawiasz: powodem trzykrotnego wywo³ania 
    sync jest to, i¿ we wczesnych dniach Unixa osobne trzykrotne wpisywanie
    polecenia dawa³o do¶æ czasu na zakoñczenie wszelkich operacji we/wy.)
	</para>

</sect1>

<sect1>
<title>Restartowanie</title>

	<para> Restartowanie oznacza uruchamianie systemu od nowa.
    Uzyskiwane jest poprzez poprawne zamkniêcie systemu i zresetowanie
    komputera. Mo¿na je uzyskaæ
	za pomoc± opcji <option>-r</option> <command>shutdown</command>
	</para>
	
	<para> W wiêkszo¶ci systemów wywo³anie
    <command>shutdown -r now</command> nastêpuje po naci¶niêciu
	ctrl-alt-del.  Akcja wywo³ywana ctrl-alt-del jest konfigurowalna
    (zobacz inittab). W systemach publicznie dostêpnych takie dzia³anie
    powinno byæ zablokowane.
	</para>

</sect1>

<sect1>
<title>Tryb jednego u¿ytkownika</title>

	<para> Polecenie <command>shutdown</command> mo¿e s³u¿yæ do
    przej¶cia w tryb jednego u¿ytkownika, w którym tylko root
    ma prawo siê zalogowaæ.
	</para>

</sect1>

<sect1>
<title>Dyskietki ratunkowe</title>

	<para> Czasami mo¿e siê zdarzyæ, i¿ komputer nie mo¿e wystartowaæ korzystaj±c
    z dysku twardego (np. b³±d podczas konfiguracji LILO).
    W takiej sytuacji dyskietki staj± siê bardzo przydatne.
	</para>

	<para> W wiêkszo¶ci dystrybucji istniej± specjalne programy s³u¿±ce
    do tworzenia dyskietek startowych.
    Je¿eli takie 'ogólne' dyskietki nie wystarczaj±
    mo¿na stworzyæ w³asne -	<citetitle>Bootdisk HOWTO</citetitle> Grahama Chapmana
    opisuje proces ich tworzenia.
	</para>
</sect1>
</chapter>

<chapter id="init">
<title><command>init</command></title>

	<para> 

	<blockquote><para> <quote>Uuno on numero yksi</quote>
	(slogan serii fiñskich filmów.)</para></blockquote>

	</para>

	<para> Rozdzia³ opisuje dzia³anie procesu <command>init</command>,
    który jest jedynym programem uruchamianym automatycznie przez
    j±dro i na którym ci±¿y wiele obowi±zków.
	</para>
	
<sect1>
<title><command>init</command> jest pierwszy</title>

	<para> <command>init</command> jest niezbêdny do dzia³ania Linuxa.
    Wiêkszo¶æ dystrybucji przychodzi z dobrze skonfigurowanym programem
	<command>init</command>, którym nie musisz siê martwiæ.
	Zazwyczaj z <command>initem</command> spotkasz siê chc±c
    utworzyæ dodatkowe terminale, zmieniæ domy¶lny poziom pracy.
	</para>

	<para> J±dro po wszelkich czynno¶ciach zwi±zanych z w³asn± inicjalizacj±
    uruchamia program <command>init</command>. 
    Dlatego <command>init</command> ma zawsze id = 1.</para>
	
	<para> Linux szuka programu w kilku miejscach, jednak standardow±
    lokacj± jest <filename>/sbin/init</filename>. 
    Je¿eli j±dro nie znajdzie programu spróbuje uruchomiæ
    <filename>/bin/sh</filename>, je¿eli to równie¿ siê nie uda
    system przestaje dzia³aæ.
	</para>
	
	<para> <command>init</command> uruchamia skrypty administracyjne
    odpowiedzialne za sprawdzenie i zamontowanie systemów plików,
    wyczyszczenie <filename>/tmp</filename>, uruchomienie
    demonów oraz <command>getty</command> na odpowiednich terminalach.
	(zobacz <xref linkend="log-in-and-out"/>).</para>
	
	<para> W czasie dzia³ania systemu <command>init</command>
    restartuje <command>getty</command> na terminalu, z którego u¿ytkownik
    siê wylogowa³. Program adoptuje wszelkie osierocone procesy
    (których rodzic umar³ przed zakoñczeniem pracy potomka).
    Jest to bardzo wa¿ne - proces bez potomka nie mo¿e istnieæ, procesy
    musz± tworzyæ sk³adne drzewo.
    
		<footnote><para> Sam <command>init</command> nie umiera nigdy.
        Nie mo¿esz go zabiæ sygna³em SIGKILL.  </para></footnote>
	
	Istnieje kilka odmian <command>inita</command>, wiêkszo¶æ dystrybucji
    Linuxa rozprowadzana jest z wersj± opart± o 
	<command>sysvinit</command> (napisany przez Miquela
	van Smoorenburga), który oryginalnie pojawi³ siê w Systemie V.
	Istnieje równie¿ wersja BSD. G³ówna ró¿nica polega na tym,
    ¿e System V posiada poziomy pracy, których w BSD brakuje.
    Informacje odnosz± siê do <command>sysvinit</command>.  </para>

</sect1>

<sect1>
<title>Plik <filename>/etc/inittab</filename></title>

	<para> Startuj±c <command>init</command> odczytuje plik <filename>/etc/inittab</filename>.
    Odczytuje go ponownie po otrzymaniu sygna³u SIGHUP,
	
		<footnote><para> Mo¿esz go wys³aæ wydaj±c polecenie <command>kill -HUP
		1</command>(bêd±c rootem oczywi¶cie)</para></footnote>
		
	co eliminuje konieczno¶æ restartowania systemu po zmianie tego¿
    pliku.
	</para>
	
	<para> Plik <filename>/etc/inittab</filename> mo¿e wydawaæ siê nieco skomplikowanym
    jednak szybko go poznasz. Zaczniemy od omówienia sposobu w³±czenia
	oczekuj±cych <command>getty</command>. Linia w pliku <filename>/etc/inittab</filename>
    ma nastêpuj±c± postaæ:

<screen>
id:poziomy_pracy:akcja:proces
</screen>

	Dodatkowo plik mo¿e zawieraæ linie: puste i zaczynaj±ce siê znakiem hash
    (`<literal>#</literal>'); obie s± ignorowane.
	
	<glosslist>
	<glossentry><glossterm>id</glossterm>
		<glossdef><para> 
		Identyfikator linii. W przypadku 
		<command>getty</command> najczê¶ciej okre¶la numer terminala, na którym
        program powinien nas³uchiwaæ
		(znak po <filename>/dev/tty</filename>). Powinien byæ unikalny i mieæ
        okre¶lony rozmiar, nic wiêcej.
		</para></glossdef></glossentry>

	<glossentry><glossterm>poziomy_pracy</glossterm>
		<glossdef><para> 
        Poziomy pracy, na których powinno siê wykonaæ zawarto¶æ linijki.
        Podaje siê je jako liczby bez ¿adnych separatorów (np. 345).
		(poziomy pracy omówione s± w nastêpnej sekcji.)
		</para></glossdef></glossentry>
			
	<glossentry><glossterm>akcja</glossterm>
		<glossdef><para> 
		<literal>respawn</literal> oznacza, ¿e program powinien byæ restartowany,
        <literal>once</literal> oznacza pojedyñcze uruchomienie programu.
		</para></glossdef></glossentry>
			
	<glossentry><glossterm>proces</glossterm>
		<glossdef><para> 
		Polecenie do wykonania.
		</para></glossdef></glossentry>
	
	</glosslist>

	Aby uruchomiæ <command>getty</command> na pierwszym wirtualnym terminalu
    (<filename>/dev/tty1</filename>) we wszystkich trybach dostêpnych dla
    u¿ytkowników (2-5) powinni¶my wstawiæ:

<screen>
1:2345:respawn:/sbin/getty 9600 tty1
</screen>

	Pierwsze pole mówi, ¿e proces pracuje na <filename>/dev/tty1</filename>.
    Drugie oznacza, ¿e robi to na poziomach pracy 2, 3, 4, 5.
    Trzecie nakazuje restart polecenia po zakoñczeniu dzia³ania.
    Ostatnie pole jest poleceniem do wykonania.
	
		<footnote><para> Ró¿ne wersje <command>getty</command> 
        wymagaj± ró¿nych opcji. Szukaj±c szczegó³ów zajrzyj do
        strony podrêcznika.
		</para></footnote>
	</para>
	
	<para> Chc±c dodaæ wiêcej terminali lub linii dial-in 
    (logowanie siê przez modem) zmieñ odpowiednio 
	<filename>/etc/inittab</filename>. Sprawd¼ strony podrêcznika
    dotycz±ce: <command>init</command>, <filename>inittab</filename>,
	<command>getty</command>.</para>
	
	<para> Je¿eli nie uda³o siê uruchomiæ polecenia, a
    <command>init</command> zosta³ skonfigurowany do 
	<literal>restartowania</literal> go system zostanie powa¿nie obci±¿ony
    niekoñcz±cymi siê restartami. Aby temu zapobiec
	<command>init</command> zapisuje informacje o czêstotliwo¶ci restartowania
    programu, je¿eli odbywa siê to zbyt czêsto program poczeka
    5 minut przed kolejn± prób±.
	</para>

</sect1>

<sect1>
<title>Poziomy pracy</title>

	<para> <glossterm>Poziom pracy</glossterm> to stan programu
	<command>init</command>, oraz ca³ego systemu definiuj±cy
    dzia³aj±ce us³ugi. Poziomy pracy identyfikowane s± poprzez liczby,
    zobacz <xref linkend="run-levels"/>. Nie istniej± definicje
    poziomów pracy konfigurowalnych przez u¿ytkownika (2-5).
    Niektórzy administratorzy systemów u¿ywaj± ich do definiowania
    dzia³aj±cych podsystemów, np.: dzia³aj±ca sieæ, X, itd.
    Inni w razie potrzeby uruchamiaj± je rêcznie. Musisz sam zdecydowaæ,
    choæ ³atwiej bêdzie podporz±dkowaæ siê podej¶ciu twojej dystrybucji.
	</para>
	
		<table id="run-levels">
		<title>Poziomy pracy w liczbach</title>
		<tgroup cols="2">
		<tbody>
		<row> <entry>0</entry> <entry>Zatrzymanie systemu.</entry> </row>
		<row> <entry>1</entry> <entry>Tryb jednego u¿ytkownika (dla specjalnej administracji).</entry> </row>
		<row> <entry>2-5</entry> <entry>Normalne dzia³anie (zdefiniowane przez u¿ytkownika).</entry> </row>
		<row> <entry>6</entry> <entry>Restart systemu.</entry> </row>
		</tbody>
		</tgroup>
		</table>

	<para> Poziomy pracy zdefiniowane s± w <filename>/etc/inittab</filename> poprzez
    nastêpuj±ce linie:

<screen>
l2:2:wait:/etc/init.d/rc 2
</screen>

    Pierwsze pole jest identyfikatorem, drugie oznacza 2 poziom pracy.
    Nastêpne pole oznacza, ¿e 
	<command>init</command> powinien uruchomiæ program raz i czekaæ
    na jego zakoñczenie.
	<filename>/etc/init.d/rc</filename> jest skryptem odpowiedzialnym
    za uruchomienie i zatrzymanie us³ug, które umo¿liwiaj± przej¶cie
    na poziom 2.
	</para>
	
	<para> Polecenie z czwartego pola robi ca³± czarn± robotê zwi±zan±
    ze zmian± poziomu pracy. Uruchamia us³ugi zdefiniowane dla poziomu
    2 i zatrzymuje programy, które nie powinny na tym poziomie dzia³aæ.
    Dzia³anie tego skryptu zale¿ne jest od dystrybucji i administratora.
	</para>
	
	<para> Podczas startu, <command>init</command> szuka linijki definiuj±cej
    domy¶lny tryb pracy:

<screen>
id:2:initdefault:
</screen>

	W czasie startu systemu (np. za pomoc± LILO)
    mo¿na przekazaæ j±dru argument ustanawiaj±cy inny pocz±tkowy
    poziom pracy, np.: 
	<literal>single</literal>, lub <literal>emergency</literal>
    umo¿liwiaj±c start systemy w trybie jednego u¿ytkownika.
    </para>
	
	<para> W czasie pracy systemu poziom dzia³ania mo¿na zmieniæ
    za pomoc± programu <command>telinit</command>.
	</para>

</sect1>

<sect1>
<title>Specjalna konfiguracja w <filename>/etc/inittab</filename></title>

	<para> Za pomoc± <filename>/etc/inittab</filename> mo¿na skonfigurowaæ
    <command>inita</command> aby reagowa³ w szczególnych przypadkach.
    Jest to mo¿liwe poprzez umieszczenie odpowiedniego napisu w
    trzecim polu. Przyk³ady:
	
	<glosslist>

	<glossentry><glossterm><literal>powerwait</literal></glossterm>
		<glossdef><para> 
		Umo¿liwia <command>initowi</command> zamkn±æ system w przypadku
        braku zasilania. Potrzebny jest UPS i specjalne oprogramowanie,
        które poinformuje 
		<command>inita</command> o wyczerpuj±cym siê zasilaniu.
		</para></glossdef></glossentry>

	<glossentry><glossterm><literal>ctrlaltdel</literal></glossterm>
		<glossdef><para> 
		Uruchamiane po naci¶niêciu ctrl-alt-del na klawiaturze konsoli.
        Domy¶ln± akcj± jest restart systemu, jednak mo¿na to ³atwo zmieniæ
		(np. na wywo³anie <command>nethack</command>.).
		</para></glossdef></glossentry>

	<glossentry><glossterm><literal>sysinit</literal></glossterm>
		<glossdef><para> 
        Polecenie uruchamiane podczas startu systemu. Najczê¶ciej
        zadaniem polecenia jest wyczyszczenie 
		<filename>/tmp</filename>, itp.
		</para></glossdef></glossentry>

	</glosslist>
	
	Nie jest to ca³a lista. Chc±c poznaæ resztê zajrzyj do podrêcznika.
	</para>

</sect1>

<sect1>
<title>Startowanie w trybie jednego u¿ytkownika</title>

	<para> Jest to bardzo wa¿ny tryb pracy, który umo¿liwia
    administratorowi wykonanie pewnych zadañ,
    
		<footnote><para> Prawdopodobnie nie powiniene¶ go u¿ywaæ do
        grania w <command>nethack</command>.</para></footnote>
		
	takich jak uruchomienie <command>fsck</command> dla partycji
	<filename>/usr</filename>, które wymaga zamkniêcia wszystkich
    programów u¿ywaj±cych tego systemu plików.
	</para>

	<para> Dzia³aj±cemu systemowi mo¿na zmieniæ poziom pracy za pomoc±
    polecenia <command>telinit</command>. Podczas startu mo¿na j±dru
    przekazaæ s³owo <literal>single</literal>, lub <literal>emergency</literal>:
    j±dro przekazuje swoje argumenty programowi <command>init</command>,
    dziêki temu program wie jaki jest domy¶lny tryb pracy.
	</para>
	
	<para> Skrypty startowe automatycznie przejd± do trybu jednego u¿ytkownika
    w przypadku b³êdu <command>fsck</command>. Ma to na celu
    uniemo¿liwiæ u¿ycie tak zepsutego systemu plików, z którym
    <command>fsck</command> nie móg³ sobie automatycznie poradziæ.
	</para>
	
	<para> Ze wzglêdów bezpieczeñstwa, w trybie jednego u¿ytkownika, system 
    powinien sprawdzaæ has³o przed uruchomieniem pow³oki. Dobrym 
    pomys³em jest uniemo¿liwienie podawania j±dru argumentów bez
    uprzedniej autoryzacji. Ma to równie¿ pewn±
    wadê - w przypadku uszkodzenia <filename>/etc/passwd</filename> 
    (<filename>/etc/shadow</filename>) zalogowanie siê bêdzie niemo¿liwe.
	</para>
</sect1>
</chapter>

<chapter id="log-in-and-out">
<title>Logowanie siê</title>

	<blockquote><para> <quote>Nie zale¿y mi na cz³onkowstwie w klubie,
    który akceptuje jako cz³onków takich ludzi jak ja.
	</quote>
	(Groucho Marx)</para></blockquote>

	<para> 
	Sekcja opisuje niuanse logowania siê do systemu.
	</para>

<sect1>
<title>Logowanie siê via terminal</title>

	<para> <xref linkend="terminal-logins"/> obrazuje zachodz±ce procesy.
    Najpierw <command>init</command> uruchamia dla odpowiedniego
    terminala program <command>getty</command>. <command>getty</command> 
    oczekuje powiadomienia od u¿ytkownika (oznacza to, ¿e u¿ytkownik
    musi co¶ napisaæ). Je¿eli po drugiej stronie jest u¿ytkownik
	<command>getty</command> wy¶wietli przywitanie 
	(zawarto¶æ pliku <filename>/etc/issue</filename>) i poprosi
    o nazwê u¿ytkownika, po czym uruchomi program <command>login</command>.
	<command>login</command> odbiera nazwê u¿ytkownika jako parametr
    i prosi o has³o. Je¿eli siê zgadzaj± program uruchamia wybran± przez
    u¿ytkownika pow³okê; w innym wypadku program koñczy dzia³anie
    (zazwyczaj najpierw daje u¿ytkownikowi kilka prób wprowadzenia
    has³a).
    
	<command>init</command> zauwa¿y, ¿e proces zosta³ zakoñczony i
    uruchomi nowe <command>getty</command> dla terminala.
	</para>
	
		<figure id="terminal-logins" float="1">
		<title>Logowanie siê poprzez terminale: interakcja pomiêdzy: <command>init</command>, <command>getty</command>, <command>login</command> i pow³ok±.</title>
		<graphic fileref="logins-via-terminals"></graphic>
		</figure>

	<para> Zauwa¿, ¿e tylko <command>init</command> tworzy nowy proces
    (korzystaj± z wywo³ania systemowego <function>fork</function>); <command>getty</command>,
	<command>login</command> zamieniaj± program, z którego zosta³y
    wywo³ane (za pomoc± wywo³ania systemowego <function>exec</function>).
	</para>

	<para> W przypadku ³±cz szeregowych potrzebny jest osobny program
    do oczekiwania na u¿ytkownika - sprawdzenie jego obecno¶ci
    mo¿e byæ (i tradycyjnie by³o) trudne.
	<command>getty</command> obs³uguje równie¿ ustawienia takie jak prêdko¶æ,
    co czyni go programem przydatnym przy tworzeniu po³±czeñ dial-in,
    w przypadku których ustawienia te zmieniaj± siê dynamicznie.
	</para>

	<para> Istnieje kilka wersji programów <command>getty</command> i
	<command>init</command>, ka¿da z nich ma swoje wady i zalety.
    Powiniene¶ zapoznaæ siê ze wszystkimi udostêpnianymi przez
    swoj± dystrybucjê, oraz o innych (aby znale¼æ je mo¿esz skorzystaæ
    z Mapy Oprogramowania Linuxowego).
	Je¿eli nie tworzysz po³±czeñ dial-in prawdopodobnie nie musisz
    siê zajmowaæ <command>getty</command>, jednak <command>init</command> 
    jest nadal wa¿ny.  </para>

</sect1>

<sect1>
<title>Logowanie siê poprzez sieæ</title>

	<para> Komputery w tej samej sieci najczê¶ciej po³±czone s±
    pojedynczym fizycznym kablem. Programy komunikuj±c siê poprzez sieæ
    tworz± <glossterm>wirtualne po³±czenie</glossterm>, co¶ na
    kszta³t kabla. Programy bior±ce udzia³ w komunikacji maj± wy³±czno¶æ
    na swoje ³±cze. Poniewa¿ po³±czenie jest wirtualne systemy
    operacyjne dwóch komputerów mog± miêdzy sob± utworzyæ ich wiele.
    W ten sposób za pomoc± jednego kabla fizycznego kilka programów
    mo¿e komunikowaæ siê jednocze¶nie. Do jednego kabla mo¿na
    równie¿ pod³±czyæ kilka komputerów, ka¿dy z nich mo¿e tworzyæ
    po³±czenia, przy czym pojedynczy komputer otrzymuje dane tylko dla siebie
    (chyba, ¿e siê pobawisz i to zmienisz ;-).
	</para>

	<para> Zazwyczaj w systemie dzia³a demon inetd (mo¿naby go
    porównaæ do <command>getty</command>), który czeka na przychodz±ce
    po³±czenia (logowania). Je¿eli takie nast±pi uruchamia program
    odpowiedzialny za dalsz± czê¶æ rozmowy. Oryginalny program dalej
    nas³uchuje.
	</para>

	<para> Powsta³o wiele protoko³ów odpowiedzialnych
    za sieciowe logowanie.
	Najwa¿niejszymi s±: <command>telnet</command>, <command>rlogin</command>
    i <command>ssh</command> (zalecany). Istnieje równie¿ wiele innych 
    protoko³ów, które s³u¿± do ró¿nych rzeczy, np.: FTP, HTTP, Gopher, SMTP, 
    POP3, ..., mo¿naby tak d³ugo wymieniaæ. Dlatego, w celu zmniejszenia 
    obci±¿enia systemu, powsta³ <command>inetd</command> - program, który
    oczekuje próby po³±czenia siê i w razie potrzeby uruchamia odpowiedni
    program. W <citetitle>Linux Network Administrators' Guide</citetitle>
    znajdziesz wiêcej informacji.</para>

</sect1>

<sect1>
<title>Co robi <command>login</command>?</title>

	<para> Program jest odpowiedzialny za autoryzacjê u¿ytkownika
    (upewnia siê, ¿e nazwa i has³o pasuj±), oraz 
    inicjalizacjê jego ¶rodowiska - ustawienie odpowiednich
    praw dostêpu do ³±cza szeregowego, uruchomienie pow³oki.
	</para>

	<para> Czê¶ci± inicjalizacji ¶rodowiska jest wy¶wietlenie
	pliku <filename>/etc/motd</filename> ( plik <filename>.hushlogin</filename>
    w katalogu domowym wy³±cza takie dzia³anie ).  </para>

	<para> Plik <filename>/etc/nologin</filename>
    blokuje wszelkie próby zalogowania siê ( jest zazwyczaj tworzony
    przez <command>shutdown</command> ).
	<command>login</command> odmawiaj±c wy¶wietli zawarto¶æ tego¿ pliku.
	</para>

	<para>  <command>login</command> loguje wszelkie niepoprawne próby zalogowania
    siê poprzez <command>sysloga</command>. Loguje równie¿ wszelkie logowania
    dokonane przez roota, umo¿liwiaj±c w ten sposób wytropienie w³amywaczy.</para>

	<para>  Aktualnie zalogowani u¿ytkownicy umieszczani s± w
	<filename>/var/run/utmp</filename>. Plik ten przy ka¿dym restarcie
    systemu jest usuwany. Polecenia takie jak: <command>who</command>, <command>w</command>
    opieraj± siê na jego zawarto¶ci.
	</para>

	<para>  Wszelkie poprawne logowania siê zapisywane s± w 
	<filename>/var/log/wtmp</filename>. Co jaki¶ czas powiniene¶ go
    usun±æ - nie istniej± ¿adne ograniczenia co do jego rozmiaru.
	
		<footnote><para> Porz±dne dystrybucje robi± to 'po rozpakowaniu'.
		</para></footnote>
		
	Program <command>last</command> przegl±da <filename>wtmp</filename>.
    </para>

	<para> <filename>utmp</filename> i <filename>wtmp</filename> s± w formacie
    binarnym (zobacz stronê podrêcznika o <filename>utmp</filename>) przez
    co przegl±danie ich zawarto¶ci wymaga specjalnych programów.
	</para>

</sect1>

<sect1>
<title>X i xdm</title>

	<para>  XXX X implementuje logowania poprzez xdm; jak równie¿: xterm -ls </para>

</sect1>

<sect1>
<title>Kontrola dostêpu</title>

	<para> Baz± u¿ytkowników jest zazwyczaj plik 
	<filename>/etc/passwd</filename>. Niektóre systemy posiadaj± dodatkowy
    plik <filename>/etc/shadow</filename>, który zawiera has³a.
	Istniej± równie¿ inne metody przechowywania informacji o u¿ytkownikach,
    dla przyk³adu: NIS.
	</para>

	<para> Baza u¿ytkowników zawiera nie tylko has³a, np.:
    imiona i nazwiska, katalogi domowe, pow³oki logowania. 
    Poniewa¿ dostêp to takiej bazy wymagany jest przez wszystkich u¿ytkowników,
    has³a przechowywane s± w postaci zakodowanej. Aby zapobiec
    brutalnym atakom maj±cym na celu z³amanie hase³, z czasem zosta³y one
    przeniesione do innego pliku, który tylko root mo¿e czytaæ (choæ kodowanie
    nadal pozosta³o).
	</para>

	<para>  Wa¿ne jest aby w systemie nie by³o ¿adnych s³abych hase³,
    aby takie wy³apaæ mo¿na pos³u¿yæ siê programem <command>crack</command>.
    Jest to dwusieczny miecz - je¿eli agresor bêdzie pierwszy uda mu siê w³amaæ
    do systemu. Mo¿na tak skonfigurowaæ <command>passwd</command> aby 
    odrzuca³ proste has³a - dziêki czemu oszczêdzisz wiele cykli CPU -
    ³amanie wymaga znacznie wiêcej mocy obliczeniowej.
	</para>

	<para> Baza grup u¿ytkowników standardowo przechowywana jest w 
    pliku <filename>/etc/group</filename>; 'ukrywane has³a' znajduj± siê w
    <filename>/etc/shadow.group</filename>.
	</para>

	<para> Zazwyczaj root mo¿e zalogowaæ siê tylko poprzez terminale
	wymienione w <filename>/etc/securetty</filename>. W ten sposób
    bezpo¶rednie zalogowanie siê jako superu¿ytkownik wymaga fizycznego 
    dostêpu. Jednocze¶nie, zwyk³y u¿ytkownik, mo¿e zalogowaæ siê
    jako root za pomoc± programu <command>su</command> (trzeba znaæ dwa has³a).  </para>

</sect1>

<sect1>
<title>Start pow³oki</title>

	<para> Zazwyczaj pow³oka logowania w czasie startu wykonuje kilka
    skryptów. Ró¿ne pow³oki u¿ywaj± ró¿nych plików; sprawd¼ dokumentacjê
    swojej.
	</para>

	<para> Zazwyczaj istnieje globalny plik (dla pow³oki	Bourne'a
    jest to <filename>/etc/profile</filename>), oraz plik u¿ytkownika
    (<filename>.profile</filename>). Dziêki tym plikom odpowiednio
    administrator, u¿ytkownik mo¿e ustawiæ ró¿ne zmienne (np. PATH), wykonaæ
    jakie¶ programy, itd.
	</para>
</sect1>
</chapter>


<chapter>
<title>Zarz±dzanie kontami u¿ytkowników</title>

	<blockquote><para> <quote>Sysadmini i handlarze prochami s± podobni:
    odmierzaj± rzeczy w K-ach i maj± swoich u¿ytkowników.</quote>
	(stary, zmêczony dowcip komputerowy.)</para></blockquote>

	<para> Rozdzia³ zawiera informacje na temat tworzenia kont u¿ytkowników,
    ich usuwania, oraz zmieniania w³a¶ciwo¶ci.
	Ró¿ne dystrybucje maj± ró¿ne narzêdzia, choæ istniej± równie¿ ogólne metody.
    </para>
		
<sect1>
<title>Konto - co to?</title>

	<para> Kiedy komputer jest u¿ywany przez wielu ludzi zazwyczaj
    tworzy siê informacje rozró¿niaj±ce ich, dziel±ce ich dane (aby
    sobie w drogê nie wchodzili ;-). Jest to wa¿ne, nawet je¿eli tylko jeden
    u¿ytkownik mo¿e pracowaæ jednocze¶nie.
	
		<footnote><para> By³oby to nieco krêpuj±ce, gdyby moja siostra
        mog³a czytaæ moje listy mi³osne.
        </para></footnote>
		
	Zatem ka¿demu u¿ytkownikowi przydzielana jest unikalna nazwa,
    któr± podaje siê podczas logowania.
	</para>
	
	<para> <glossterm>Konto</glossterm> to wszystkie pliki, zasoby i
    informacje nale¿±ce do u¿ytkownika. W komercyjnych systemach,
    konta s± podobne to tych w banku - istnieje jaka¶ warto¶æ pocz±tkowa
    (odpowiednia ilo¶æ pieniêdzy), która kurczy siê zale¿nie od 
    potrzeb u¿ytkownika - zale¿nie od tego w jakim stopniu wykorzystuje 
    system. Dla przyk³adu: mo¿emy wyceniæ wykorzystanie dysków,
    procesora, itp.
	</para>
	
</sect1>

<sect1>
<title>Tworzenie u¿ytkownika</title>

	<para> J±dro Linuxa traktuje u¿ytkowników jako liczby.
    Ka¿dy u¿ytkownik identyfikowany jest poprzez unikaln± liczbê
    ca³kowit± - <glossterm>id u¿ytkownika</glossterm>, lub <glossterm>uid</glossterm>,
    dzieje siê tak dlatego, ¿e liczby najszybciej siê przetwarza.
    Zewnêtrzna baza zawiera odpowiednie przypisania -
    <glossterm>u¿ytkownik</glossterm> i jego identyfikator. 
    </para>
	
	<para>  Aby stworzyæ u¿ytkownika nale¿y zmieniæ bazê u¿ytkowników,
    utworzyæ katalog domowy. Mo¿na go równie¿ pouczyæ i przygotowaæ mu
    ¶rodowisko pracy.
	</para>
	
	<para> Wiêkszo¶æ dystrybucji posiada w³a¶ciwe sobie programy, np.
    pracuj±ce w ¶rodowisku graficznym.
    Zazwyczaj ogólnie rozprowadzanymi s±: <command>adduser</command>
    i <command>useradd</command>. <xref linkend="manual-adduser"/>
    opisuje rêczne dodawanie u¿ytkowników.
	</para>
	
<sect2>
<title><filename>/etc/passwd</filename> i inne pliki</title>

	<para>  Podstawow± baz± u¿ytkowników w Uniksach jest plik
    textowy <filename>/etc/passwd</filename> (nazywany <glossterm>plikiem
    hase³</glossterm>), który zawiera wszystkich poprawnych u¿ytkowników,
    oraz niektóre informacje o nich. Na jednego u¿ytkownika przypada
    jedna linia zawieraj±ca siedem, oddzielonych dwukropkami, pól:

	<itemizedlist>
	
	<listitem><para> Nazwa u¿ytkownika.</para></listitem>
	<listitem><para> Has³o w postaci zakodowanej.</para></listitem>
	<listitem><para> Numeryczny identyfikator u¿ytkownika.</para></listitem>
	<listitem><para> Numeryczny identyfikator grupy.</para></listitem>
	<listitem><para> Imiê i nazwisko, oraz dodatkowy opis u¿ytkownika.</para></listitem>
	<listitem><para> Katalog domowy.</para></listitem>
	<listitem><para> Pow³oka logowania (program uruchamiany po zalogowaniu siê).</para></listitem>
	
	</itemizedlist>

	Strona podrêcznika dotycz±ca <filename>passwd</filename> zawiera wiêcej
    informacji.</para>
	
	<para> Ka¿dy z u¿ytkowników mo¿e odczytaæ plik hase³, a w ten sposób
    poznaæ nazwy innych u¿ytkowników. Oznacza to, ¿e has³a (w postaci zakodowanej) 
    s± dostêpne dla wszystkich; teoretycznie nie powinno byæ to gro¼ne.
	Niestety kodowanie mo¿na z³amaæ, zw³aszcza gdy has³o jest s³abe
    (jest zbyt krótkie, mo¿na je znale¼æ w s³owniku, lub, co gorsza, domy¶leæ
    siê go). Dlatego, z czasem, has³a zosta³y przeniesione do osobnego pliku.
	</para>
	
	<para> 
    Wiele systemów zaimplementowa³o system <glossterm>ukrytych hase³
    </glossterm>. Jest to alternatywna metoda przechowywania zakodowanych
    hase³, która u¿ywa plik <filename>/etc/shadow</filename>, który
    odczytywalny jest tylko przez roota.
	<filename>/etc/passwd</filename> zawiera specjalny znacznik
    oznaczaj±cy, ¿e has³o znajduje siê gdzie¶ indziej.
	Ka¿dy program dokonuj±cy autoryzacji u¿ytkowników musi mieæ 
    ustawiony bit setuid. Normalne programy, które potrzebuj± innych
    pól, dzia³aj± bez zmian.
	
		<footnote><para> Wszystkie informacje o u¿ytkowniku 
        znajduj± siê w pliku hase³, <emphasis>za wyj±tkiem</emphasis>
        has³a :-)</para></footnote>

	</para>
	
</sect2>

<sect2>
<title>U¿ywanie numerycznych identyfikatorów</title>

	<para>  Najczê¶ciej nie musisz znaæ numerycznych numerów identyfikacyjnych,
    jednak wiedza ta staje siê potrzebna gdy u¿ywasz Sieciowego systemu plików
    (NFS) - na wszystkich komputerach identyfikatory musz± siê zgadzaæ.
    Dzieje siê tak poniewa¿ NFS rozró¿nia u¿ytkowników po ich identyfikatorach
    numerycznych.
	</para>
	
	<para>  Chc±c u¿ywaæ NFS musisz wynale¼æ mechanizm synchronizacji
    informacji o kontach. W tym celu mo¿na u¿yæ systemu NIS
    (opis w network-admin-guide).  </para>
	
	<para>  Zasadniczo nie powiniene¶ u¿ywaæ starych identyfikatorów 
    (textowych, czy numerycznych) - nowy u¿ytkownik móg³by przej±æ 
    pliki starego u¿ytkownika.
	</para>

</sect2>

<!--
ma³y wstêp ode mnie (Pawe³ Niewiadomski)
-->
<sect2>
<title>Zarz±dzanie grupami</title>

	<para>  S± dwie szko³y zarz±dzania grupami: domy¶lnie tworzyæ
    dla ka¿dego u¿ytkownika now± grupê, lub do³±czaæ go do podanej.
    Ka¿de z tych podej¶æ ma wady i zalety.
    </para>
    
    <para>  Tworzenie osobnych grup dla u¿ytkowników zwiêksza
    bezpieczeñstwo ich danych - dodatkowa grupa praw dostêpu, któr±
    nie musz± siê zajmowaæ - prawa dla grupy nie s± wa¿ne gdy tylko jeden
    u¿ytkownik do niej nale¿y. Je¿eli chcesz zarz±dzaæ du¿± grup± u¿ytkowników,
    traktowaæ ich na równych prawach lepiej domy¶lnie umieszczaæ ich
    w jednej grupie.
    </para>

    <para>  Ja w ka¿dym przypadku powiniene¶ mieæ swoje zdanie, tylko ty
    mo¿esz okre¶liæ swoje potrzeby, wiêc sam je realizuj.
    </para>
</sect2>

<sect2>
<title>Domy¶lne ¶rodowisko: <filename>/etc/skel</filename></title>

	<para>  Zazwyczaj podczas tworzenia katalogu domowego u¿ytkownika
    zostaj± do niego skopiowane pliki z katalogu
	<filename>/etc/skel</filename>.
    Dziêki temu administrator systemu mo¿e stworzyæ 
	pliki, które dostarcz± u¿ytkownikowi przyjaznego ¶rodowiska.
	Dla przyk³adu, w pliku <filename>/etc/skel/.profile</filename> 
    mo¿na ustawiæ zmienn± EDITOR na jaki¶ edytor przyjazny nowicjuszom
    ( vi ;-).
	</para>
	
	<para>  Zazwyczaj czê¶æ konfiguracji umieszcza siê w globalnych plikach 
    konfiguracyjnych - w ten sposób gdy zmieni siê edytor mo¿esz
    szybko zaktualizowaæ ustawienia u¿ytkowników.
	Powiniene¶ pomy¶leæ nad pewnym podzia³em: zmienne, itp. lepiej 
    umieszczaæ w plikach globalnych, natomiast ustawienia dla poszczególnych
    programów, które u¿ytkownicy zapewne bêd± chcieli zmieniæ, w 
    katalogach domowych.
    </para>

</sect2>

<sect2 id="manual-adduser">
<title>Rêczne tworzenie u¿ytkownika</title>

	<para>  Aby rêcznie stworzyæ konto wykonaj nastêpuj±ce kroki:

	<itemizedlist>
	
	<listitem><para>  Zmieñ <filename>/etc/passwd</filename> za pomoc±
	<command>vipw</command>, dodaj odpowiedni± liniê dla nowego
    u¿ytkownika.
	<emphasis>Nie zmieniaj tego pliku bezpo¶rednio za pomoc± edytora!
    </emphasis> <command>vipw</command> blokuje plik, co uniemo¿liwia
    innym programom jego zmiany. Jako has³o powiniene¶ wstawiæ
    `<literal>*</literal>' - blokuj±c konto.  </para></listitem>
	
	<listitem><para>  Zmieñ <filename>/etc/group</filename>
    za pomoc± <command>vigr</command>.  </para></listitem>
	
	<listitem><para>  Utwórz katalog domowy u¿ytkownika.
	</para></listitem>
	
	<listitem><para>  Skopiuj pliki z <filename>/etc/skel</filename>
    do utworzonego katalogu.
	</para></listitem>
	
	<listitem><para>  Ustaw w³a¶ciciela i prawa dostêpu za pomoc±
	<command>chown</command> i <command>chmod</command>. Przydatn± jest
    opcja <option>-R</option>. Poprawne prawa dostêpu s± ró¿ne na ró¿nych
    systemach, jednak polecenia wygl±daæ powinny podobnie:

<screen>
<userinput>cd /home/nazwa_u¿ytkownika
chown -R nazwa.grupa .
chmod -R go=u,go-w .
chmod go= .</userinput>
</screen>

	</para></listitem>
	
	<listitem><para>  Ustaw has³o za pomoc± <command>passwd</command>.
	</para></listitem>

	</itemizedlist>
	</para>
	
	<para>  Po ustawieniu has³a u¿ytkownik mo¿e siê zalogowaæ, wiêc
    powinno to byæ ostatnim krokiem.
	</para>
	
	<para> 
	Czasami trzeba utworzyæ bezu¿ytkownikowe konto,
	dla przyk³adu: anonimowy serwer FTP potrzebuje u¿ytkownika
    ftp. W takim wypadku powiniene¶ blokowaæ takie konta
    - w ten sposób tylko root mo¿e staæ siê takim u¿ytkownikiem,
    nikt siê nie mo¿e zalogowaæ.
	</para>
	
</sect2>

</sect1>

<!--
%\section{Educating a new user}
%
%	\meta
%	make sure they know how to get help
%	large sites might want to write a small booklet (or even just
%		a couple of pages) with important stuff: how to log in
%		and out, how to change password, which systems there are,
%		how to use mail, list of people that answer questions
-->

<sect1>
<title>Zmiana ustawieñ u¿ytkownika</title>

	<para> 
	Istnieje kilka poleceñ zmieniaj±cych w³a¶ciwo¶ci konta
    (wpisy w pliku <filename>/etc/passwd</filename>):

	<glosslist>
	<glossentry><glossterm><command>chfn</command></glossterm>
		<glossdef><para>  Zmienia pole imienia.
		</para></glossdef></glossentry>
	<glossentry><glossterm><command>chsh</command></glossterm>
		<glossdef><para>  Zmienia pow³okê logowania.
		</para></glossdef></glossentry>
	<glossentry><glossterm><command>passwd</command></glossterm>
		<glossdef><para>  Zmienia has³o.
		</para></glossdef></glossentry>
	</glosslist>

	Super-u¿ytkownik mo¿e za pomoc± tych poleceñ zmieniaæ
    w³a¶ciwo¶ci dowolnego konta. '¦miertelnik' mo¿e zmieniæ dane tylko
    swojego konta. Czasami dobrze jest wy³±czyæ te polecenia
    (za pomoc± <command>chmod</command>) zwyk³ym u¿ytkownikom, dla przyk³adu:
    gdy masz du¿o nowicjuszy.
	</para>
	
	<para> 
	Inne zadania realizowane musz± byæ rêcznie. Dla przyk³adu:
    zmiana nazwy u¿ytkownika. Aby dodaæ/usun±æ grupê
    musisz zmieniæ <filename>/etc/group</filename> (za pomoc± <command>vigr</command>). 
    Takie sytuacje s± rzadkie, jednak siê zdarzaj±.
	</para>
	
</sect1>

<sect1>
<title>Usuwanie u¿ytkownika</title>

	<para>  Przed usuniêciem u¿ytkownika usuñ wszystkie jego pliki,
    skrzynki pocztowe, aliasy pocztowe, ¿±dania drukowania,
    prace <command>crona</command> i <command>at</command>,
    oraz wszelkie inne odwo³ania do niego. Teraz mo¿esz usun±æ
    wpisy w <filename>/etc/passwd</filename> i <filename>/etc/group</filename>
    (pamiêtaj o usuniêciu nazwy u¿ytkownika ze wszystkich grup, do których
    by³ dodany). Dobrym pomys³em jest zablokowanie konta (powy¿ej) przed
    powy¿szymi czynno¶ciami.
	</para>
	
	<para> 
	Pamiêtaj, ¿e u¿ytkownicy mog± mieæ jakie¶ pliki poza swoimi katalogami
    domowymi. Polecenie <command>find</command> pomo¿e Ci je znale¼æ:

<screen>
find / -user nazwa_u¿ytkownika 
</screen>

	Pamiêtaj, ¿e to wykonanie polecenia mo¿e zaj±æ
	<emphasis>du¿o</emphasis> czasu, zale¿nie od ilo¶ci danych. 
    Je¿eli czê¶æ dysków montowana jest przez sieæ mo¿e to znacz±co
    j± obci±¿yæ (i serwer).
	</para>
	
	<para>  Niektóre dystrybucje Linuxa posiadaj± program
	<command>deluser</command>, lub <command>userdel</command>, który
    s³u¿y do automatycznego usuwania u¿ytkowników.
	</para>

</sect1>

<sect1>
<title>Tymczasowe blokowanie u¿ytkownika</title>

	<para>  Czasami trzeba okresowo zablokowaæ konto, bez usuwania go.
    Dla przyk³adu: u¿ytkownik nie ui¶ci³ op³aty, lub cracker
    dorwa³ has³o.
	</para>
	
	<para>  Najlepszym sposobem na zablokowanie konta jest zmiana
    pow³oki na program wy¶wietlaj±cy wiadomo¶ci. Dziêki czemu
    u¿ytkownik dostanie odpowiedni± wiadomo¶æ. 
	</para>
	
	<para> 
	Mo¿naby równie¿ zmieniæ nazwê u¿ytkownika, lub has³o, jednak
    w tym przypadku u¿ytkownik nie bêdzie wiedzia³ co siê dzieje.
	Niedoinformowani u¿ytkownicy oznaczaj± wiêcej pracy.
	
		<footnote><para> Ale s± tacy <emphasis>zabawni</emphasis> je¿eli
        jeste¶ BOFH.</para></footnote>

	</para>
	
	<para>  Prostym sposobem na stworzenie takich informacji s± 
	'skrypty tail':

<screen>
#!/usr/bin/tail +2
Konto zosta³o zablokowane z powodu naruszenia zasad bezpieczeñstwa.
Zadzwoñ pod numer 555-1234 i czekaj na zjawienie siê ludzi w czerni.
</screen>

	Pierwsze dwa znaki (`<literal>#!</literal>') mówi± j±dru, ¿e plik bêdzie interpretowany
 przez zewnêtrzny program, reszta lini okre¶la jakie polecenie
 nale¿y wykonaæ aby zinterpretowaæ plik.
    W tym wypadku polecenie <command>tail</command> wy¶wietli 2 ostatnie
    linie wej¶cia.
	</para>
	
	<para> 
	Je¿eli podejrzewasz, ¿e konto billg zosta³o przejête móg³by¶ zrobiæ
    co¶ takiego:

<screen>
<prompt>#</prompt> <userinput>chsh -s /usr/local/lib/no-login/security billg</userinput>
<prompt>#</prompt> <userinput>su - billg</userinput>
Konto zosta³o zablokowane z powodu naruszenia zasad bezpieczeñstwa.
Zadzwoñ pod numer 555-1234 i czekaj na zjawienie siê ludzi w czerni.
<prompt>#</prompt>
</screen>

	Polecenie <command>su</command>, w tym przypadku, s³u¿y do przetestowania zmiany.
    </para>

</sect1>

<!--
%\section{Accounting}
%
%	\meta
%	sac et al
-->

</chapter>

<chapter id="backups">
<title>Kopie zapasowe</title>

	<blockquote><para> <literallayout>
Sprzêt jest nieokre¶lenie pewny.
Oprogramowanie jest okre¶lenie zawodne.
Ludzie s± nieokre¶lenie zawodni.
Natura jest okre¶lenie pewna.
</literallayout></para></blockquote>

	<para>  Rozdzia³ t³umaczy dlaczego, jak i kiedy tworzyæ kopie
    zapasowe, oraz jak z nich skorzystaæ.
	</para>

<sect1>
<title>Potrzeba kopii zapasowych</title>

	<para>  Twoje dane s± cenne. Odtwarzanie ich wymaga czasu
    i wysi³ku, a to kosztuje Ciê zdrowie i pieni±dze; niektórych
    danych nie da siê odtworzyæ. Dlatego powiniene¶ chroniæ swoje dane.
	</para>

	<para>  Zasadniczo istniej± cztery powody, z których mo¿esz straciæ
    dane: usterka sprzêtu, pluskwa w oprogramowaniu, cz³owiek, naturalne
    katastrofy.
	
		<footnote><para> Pi±tym powodem jest "co¶ innego".</para></footnote>
		
	Pomimo tego, ¿e sprzêt staje siê coraz bardziej niezawodny, zdarzaj±
    siê usterki (czasami bardzo niespodziewanie). Najbardziej krytycznym
    medium przechowuj±cym dane jest dysk twardy, jego zasada dzia³ania
    opiera siê na malutkich polach magnetycznych stykaj±cych siê z szumem
    magnetycznym ¶wiata. Nowoczesne oprogramowanie nie stara siê byæ
    niezawodne; twardy jak ska³a program jest wyj±tkiem, nie zasad±.
    Ludzie s± zawodni, pope³niaj± b³êdy, lub umy¶lnie niszcz± dane.
    Natura p³ata figle. Wszystko wszystkim ale ma³ym cudem jest
    dzia³anie wszystkiego.
	</para>

	<para>  Kopie zapasowe s± sposobem chronienia twoich danych.
Posiadanie kilku kopii danych zapobiega przed ich utrat±, do tego
    jest znacznie tañsze ni¿ ich odtwarzanie.
	</para>

	<para>  Kopie zapasowe musz± byæ tworzone w³a¶ciwie. Jak wszystko
    co fizyczne kopie z czasem zepsuj± siê. Czê¶ci± tworzenia kopii
    zapasowej jest upewnienie siê czy dzia³a; nie chcia³by¶ siê
    o tym dowiedzieæ w razie potrzeby.
    
		<footnote><para> Nie ¶miej siê. Przydarzy³o siê to wielu ludziom.
		</para></footnote>
		
	Pamiêtaj, ¿e w czasie tworzenia kopii równie¿ co¶ siê mo¿e zdarzyæ;
    wtedy zostaniesz z rêk± w nocniku.
    
		<footnote><para> By³em, zrobi³em...</para></footnote>
		
	Mo¿e siê zdarzyæ, ¿e odtwarzaj±c kopiê zauwa¿ysz, ¿e co¶ pomin±³e¶,
    np. bazê u¿ytkowników zawieraj±c± 15000 wpisów. Oczywi¶cie, mo¿e
    siê zdarzyæ, ¿e wszystko dzia³a wspaniale, jednak twojemu ostatniemu
    streamerowi co¶ siê przydarzy³o.
	</para>

	<para>  Paranoja pomaga przy tworzeniu kopii zapasowych.
	</para>

</sect1>

<sect1>
<title>Wybór medium na kopiê zapasow±</title>

	<para>  Najwa¿niejsz± decyzj± jest wybór medium. Musisz rozwa¿yæ
    koszta, pewno¶æ, prêdko¶æ, dostêpno¶æ i u¿yteczno¶æ.
	</para>

	<para> Koszta s± wa¿ne, poniewa¿ pojemno¶æ wszystkich twoich no¶ników, przechowuj±cych kopie zapasowe, powinna byæ kilkakrotnie wiêksza ni¿ ilo¶æ danych. W wiêkszo¶ci wypadków wybiera siê najtañsze medium.
</para>

	<para>  Pewno¶æ dzia³ania jest bardzo wa¿na, zepsuta kopia zapasowa
    mo¿e doprowadziæ doros³ego cz³owieka do p³aczu. Medium musi byæ
    w stanie przechowaæ dane przez lata. Sposób u¿ycia jest równie¿ wa¿ny i
    mo¿e znacz±co wp³yn±æ na ¿ywotno¶æ kopii.
    Dysk twardy pracuje pewnie, jednak jako medium do tworzenia kopii zapasowych
    nie jest zbyt przydatny, zw³aszcza gdy znajduje siê w tym samym
    komputerze co zachowywane dane.
	</para>

	<para>  Prêdko¶æ zazwyczaj nie jest zbyt wa¿na, je¿eli mo¿na
    tworzyæ kopie bez interakcji z u¿ytkownikiem. Nie ma znaczenia
    ile tworzenie kopii zajmuje godzin dopóty, dopóki nie trzeba przy
    tym siedzieæ. Z drugiej strony je¿eli kopii zapasowej nie mo¿na wykonaæ
    w czasie bezczynno¶ci komputera prêdko¶æ zaczyna siê liczyæ.
	</para>

	<para>  Dostêpno¶æ jest oczywi¶cie niezbêdna, nie mo¿esz utworzyæ
    kopii zapasowej je¿eli medium nie istnieje. Mniej oczywista jest
    potrzeba istnienia medium w przysz³o¶ci i to nie tylko na twoim 
    komputerze. W innym przypadku nie bêdziesz móg³ odtworzyæ danych.
	</para>

	<para>  U¿yteczno¶æ jest wa¿nym czynnikiem okre¶laj±cym czêstotliwo¶æ
    wykonywania kopii. Czym ³atwiej tworzyæ kopie zapasowe tym lepiej.
    Proces ich tworzenia nie mo¿e byæ trudny ani nudny.
	</para>

	<para>  Aktualnie do wyboru mamy ta¶my, p³yty CD (lub pochodne).
    CD s± dobrym rozwi±zaniem gdy dane trzeba zarchiwizowaæ, natomiast
    w ¶wiecie kopii zapasowych nadal króluj± streamery.
	</para>
</sect1>

<sect1>
<title>Wybór programu</title>

	<para>  Istnieje wiele programów do tworzenia kopii zapasowych.
	Tradycyjnymi programami do tego przeznaczonymi s±:
	<command>tar</command>, <command>cpio</command>,
	<command>dump</command>. Wybór narzêdzia mo¿e byæ podyktowany 
    wybranym medium.
	</para>

	<para>  <command>tar</command> i <command>cpio</command> s±
    podobne. Oba programy potrafi± zapisywaæ i odczytywaæ dane
    z ta¶m, do tego potrafi± obs³u¿yæ ka¿de medium, z którym
    potrafi sobie poradziæ j±dro.
	Niektóre Unixowe wersje <command>tara</command> i
	<command>cpio</command> mog± mieæ problemy z dziwnymi plikami 
    ( dowi±zaniami symbolicznymi, plikami urz±dzeñ, itp. ), jednak
    Linuxowe wersje poradz± sobie z ka¿dym plikiem.
	</para>

	<para>  <command>dump</command> pracuje w sposób nieco odmienny
    ni¿ powy¿sze programy - odczytuje pliki bezpo¶rednio z urz±dzenia,
    bez po¶rednictwa systemu plików. Program zosta³ specjalnie
    napisany do tworzenia kopii zapasowych,
	<command>tar</command> i <command>cpio</command> powsta³y w celu archiwizowania
    danych.
	</para>

	<para>  Bezpo¶rednie odczytywanie systemu plików ma pewne zalety -
    umo¿liwia odczytywanie plików bez zmiany ich znaczników czasowych;
    u¿ywaj±c <command>tara</command>, lub <command>cpio</command>
    musia³by¶ zamontowaæ system w trybie wy³±cznie do odczytu.
    Bezpo¶rednie odczytywanie systemu plików jest wydajniejsze przy
    kopiowaniu wszystkiego. G³ówn± wad± takiego podej¶cia jest 
    ograniczenie programu do jednego systemu plików;
	Linuxowy <command>dump</command> rozumie tylko i wy³±cznie ext2.
	</para>

	<para>  <command>dump</command> ma wbudowan± obs³ugê poziomów
    kopiowania (omówimy je w dalszej czê¶ci); 
	<command>tar</command> i <command>cpio</command> wymagaj± do tego
    dodatkowych narzêdzi.
	</para>

	<para>  Porównanie niestandardowych programów przekracza ramy tej
    ksi±¿ki. 
	</para>

</sect1>

<sect1>
<title>Proste kopie zapasowe</title>

	<para>  Tworzenie takich kopii sprowadza siê do skopiowania wszystkiego
    za pierwszym razem, oraz pó¼niejszych dopisywañ.
	Pierwsza kopia nazywana jest <glossterm>pe³n±</glossterm>, pó¼niejsze
    to kopie <glossterm>ró¿nicowe</glossterm>. Odtwarzanie danych za pomoc±
    kopii ró¿nicowych wymaga odtworzenia kopii pe³nej.
	</para>

	<para>  Je¿eli chcesz tworzyæ kopie codziennie i posiadasz 6 ta¶m,
    mo¿esz 1 wykorzystaæ na pe³n± kopiê. Na ta¶mach 2 - 5 tworzyæ
    kopie inkrementacyjne, po czym tworzysz pe³n± kopiê na ta¶mie 6
    i znów wykorzystujesz ta¶my 2 - 5. Nie powiniene¶ nadpisywaæ ta¶my
    1 do czasu stworzenia pe³nej kopii (na wszelki wypadek). Po utworzeniu
    pe³nej kopii na ta¶mie 6 i przystêpuj±c do tworzenia nastêpnej 
    pe³nej kopii wykorzystujesz ta¶mê nr 1, a 6 odk³adasz na pó³kê, itd.
	</para>

	<para>  Je¿eli posiadasz wiêcej ni¿ 6 ta¶m mo¿esz dodatkowe wykorzystaæ
    do tworzenia pe³nych kopii. Za ka¿dym razem wykorzystujesz najstarsz± z
    nich podczas tworzenia nastêpnej pe³nej kopii. Posiadaj±c kilka
    pe³nych kopii mo¿esz znale¼æ plik, który aktualnie nie istnieje, lub jego
    starsz± wersjê, itp.
	</para>

<sect2>
<title>Tworzenie kopii za pomoc± <command>tara</command></title>

	<para> 
	Pe³n± kopiê mo¿na utworzyæ w sposób nastêpuj±cy:

<screen>
<prompt>#</prompt> <userinput>tar --create --file /dev/ftape /usr/src</userinput>
<computeroutput>tar: Removing leading / from absolute path names in the archive</computeroutput>
<prompt>#</prompt>
</screen>

	W powy¿szym przyk³adzie u¿ywam opcji GNU <command>tara</command>,
    oryginalny <command>tar</command> obs³uguje tylko jedno literowe
    opcje. Wersja GNU posiada równie¿ inne rozszerzenia: obs³uguje 
    bardzo d³ugie ¶cie¿ki, podzia³ archiwum na kilku mediach, itd.</para>
	
	<para>  Je¿eli twoja kopia nie mie¶ci siê na jednej dyskietce u¿yj opcji
    <option>--multi-volume</option> (<option>-M</option>):

<screen>
<prompt>#</prompt> <userinput>tar -cMf /dev/fd0H1440 /usr/src</userinput>
<computeroutput>tar: Removing leading / from absolute path names in the archive
Prepare volume #2 for /dev/fd0H1440 and hit return:</computeroutput>
<prompt>#</prompt>
</screen>

	Pamiêtaj, ¿e przed u¿yciem dyskietek powiniene¶ jest sformatowaæ.
	</para>

	<para>  Po stworzeniu kopii powiniene¶ sprawdziæ jej poprawno¶æ:

<screen>
<prompt>#</prompt> <userinput>tar --compare --verbose -f /dev/ftape</userinput>
<computeroutput>usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
....</computeroutput>
<prompt>#</prompt>
</screen>

	Pamiêtaj aby to zrobiæ, inaczej zauwa¿ysz awariê za pó¼no.
	</para>
	
	<para>  Kopia ró¿nicowa mo¿e zostaæ utworzona za pomoc± opcji 
	<option>--newer</option>(<option>-N</option>):

<screen>
<prompt>#</prompt> <userinput>tar --create --newer '8 Sep 1995' --file /dev/ftape /usr/src --verbose</userinput>
<computeroutput>tar: Removing leading / from absolute path names in the archive
usr/src/
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/modules/
usr/src/linux-1.2.10-includes/include/asm-generic/
usr/src/linux-1.2.10-includes/include/asm-i386/
usr/src/linux-1.2.10-includes/include/asm-mips/
usr/src/linux-1.2.10-includes/include/asm-alpha/
usr/src/linux-1.2.10-includes/include/asm-m68k/
usr/src/linux-1.2.10-includes/include/asm-sparc/
usr/src/patch-1.2.11.gz</computeroutput>
<prompt>#</prompt>
</screen>

	Niestety <command>tar</command> nie zauwa¿a zmian w i-wê¼le pliku
    (np. zmiana praw dostêpu, lub jego nazwy), mo¿na to obej¶æ
    wykorzystuj±c program <command>find</command>.
    Skrypty wykonuj±ce te wszystkie operacje s± dostêpne na wielu
    serwerach FTP.
	</para>
	
</sect2>

<sect2>
<title>Odtwarzanie plików za pomoc± <command>tara</command></title>

	<para>  Opcja <option>--extract</option> (<option>-x</option>)
	pomo¿e Ci odzyskaæ twoje dane:

<screen>
<prompt>#</prompt> <userinput>tar --extract --same-permissions --verbose --file /dev/fd0H1440</userinput>
<computeroutput>usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/hdreg.h
usr/src/linux-1.2.10-includes/include/linux/kernel.h
...</computeroutput>
<prompt>#</prompt>
</screen>

	Mo¿esz równie¿ wyci±gn±æ specyficzny plik, lub katalog (wraz z podkatalogami
    i zawartymi w nich plikami):

<screen>
<prompt>#</prompt> <userinput>tar xpvf /dev/fd0H1440 usr/src/linux-1.2.10-includes/include/linux/hdreg.h</userinput>
<computeroutput>usr/src/linux-1.2.10-includes/include/linux/hdreg.h</computeroutput>
<prompt>#</prompt>
</screen>

	Za pomoc± opcji <option>--list</option> (<option>-t</option>) mo¿esz
    sprawdziæ zawarto¶æ kopii zapasowej:

<screen>
<prompt>#</prompt> <userinput>tar --list --file /dev/fd0H1440</userinput>
<computeroutput>usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/hdreg.h
usr/src/linux-1.2.10-includes/include/linux/kernel.h
...</computeroutput>
<prompt>#</prompt>
</screen>

	Pamiêtaj, ¿e <command>tar</command> odczytuje dane sekwencyjnie co
    przy du¿ych archiwach jest wolne. Taka metoda dzia³ania wynika z
    budowy ta¶m ( i innych mediów sekwencyjnych ).
	</para>
	
	<para>  <command>tar</command> nie obs³uguje skasowanych plików:
    je¿eli pe³na kopia zawiera plik, natomiast kopia ró¿nicowa
    nie, plik po odtworzeniu danych bêdzie istnia³. W przypadku
    niektórych plików mo¿e to stanowiæ powa¿ny problem.
	</para>

</sect2>

</sect1>

<sect1>
<title>Kopie wielopoziomowe</title>

	<para>  Prosta metoda tworzenia kopii zapasowych jest
    dobra dla osobistych komputerów i ma³ych serwerów. Przy du¿ej
    ilo¶ci danych nale¿y zastosowaæ inne metody.
	</para>

	<para>  Prosta metoda ma dwa poziomy: pe³ny i ró¿nicowa kopia.
	Mo¿na to uogólniæ do kilku poziomów. Pe³na kopia to poziom 0,
    kopie ró¿nicowe to: 1, 2, 3, ... Na poszczególnym poziomie
    zachowujesz dane, które s± zmienione wzglêdem ni¿szego, lub
    równorzêdnego poziomu.
	</para>

	<para>  W ten sposób uzyskujemy d³u¿sz± ¿ywotno¶æ danej kopii danych,
    umo¿liwiaj±c w ten sposób dostêp do kilku wersji plików, lub danych,
    które zosta³y usuniête dawno temu.
	</para>

	<para>  Dla przyk³adu: posiadaj±c 10 ta¶m, mo¿emy 1 i 2 wykorzystywaæ
    na miesiêczne kopie (robione w pierwszy pi±tek miesi±ca),
    ta¶my 3 - 6 bêd± zawieraæ tygodniowe kopie (inne pi±tki, pamiêtaj,
    ¿e w miesi±cu mo¿e byæ 5 pi±tków, wiêc potrzebujemy 4 ta¶my),
    ta¶my 7 - 10 bêd± kopiami dziennymi (poniedzia³ek do czwartku).
    Za pomoc± dodatkowych 4 ta¶m wyd³u¿yli¶my sesjê z 2 tygodni do
    dwóch miesiêcy. Prawd± jest, i¿ nie mo¿emy odzyskaæ wszystkich wersji
    wszystkich plików, jednak to co mo¿emy odzyskaæ jest czêsto wystarczaj±ce.
	</para>

	<para> <xref linkend="backup-history-timeline"/> pokazuje, który
    poziom powinien byæ u¿yty w danym dniu, oraz z których kopii mo¿na
    odzyskaæ dane pod koniec miesi±ca.
	</para>

		<figure id="backup-history-timeline" float="1">
		<title>Przyk³adowy wielopoziomowy schemat tworzenia kopii zapasowych.
        </title>
		<graphic fileref="backup-timeline"></graphic>
		</figure>

	<para>  Poziomy kopii mog± byæ równie¿ u¿ywane do utrzymywania czasu 
    odzyskiwania danych do minimum. Je¿eli posiadasz wiele kopii ró¿nicowych
    o coraz rosn±cym jednostajnie poziomie, aby odzyskaæ wszystkie dane 
    musisz je wszystkie odczytaæ. Mo¿esz jednak tworzyæ kopie o 
    niekolejnych poziomach ograniczaj±c liczbê ta¶m niezbêdnych 
    do odtworzenia systemu.
	</para>

	<para>  Aby uzyskaæ taki efekt, mo¿esz u¿ywaæ ni¿szego poziomu dla
    ka¿dej nastêpnej kopii ró¿nicowej. Jednak¿e, w ten sposób wyd³u¿asz
    równie¿ czas tworzenia kopii (ka¿da kopia zawiera wszystko od
    poprzedniej pe³nej kopii). Lepszy schemat jest sugerowany
    przez podrêcznik programu <command>dump</command>. W skrócie
    wykonuj kolejno kopie o poziomach: 3, 2, 5, 4, 7, 6, 9, 8, 9, itd.
	W ten sposób tworzenie kopii i odzyskiwanie danych trwa krótko.
    Liczba niezbêdnych ta¶m zale¿y od tego jak d³ugie przerwy bêdziesz
    czyni³ miêdzy pe³nymi kopiami, jednak i tak bêdzie ni¿sza ni¿ w przypadku
    prostego schematu.
	</para>

<table id="efficient-backup-levels">
<title>Efektywny schemat tworzenia wielopoziomowych kopii zapasowych</title>
<tgroup cols="4">
<thead>
<row><entry>Ta¶ma</entry> <entry>Poziom</entry> <entry>Kopiowanie (dni)</entry> <entry>Ilo¶æ ta¶m niezbêdnych do odtworzenia</entry></row>
</thead>
<tbody>
<row><entry>1</entry> <entry>0</entry> <entry>n/a</entry> <entry>1</entry></row>
<row><entry>2</entry> <entry>3</entry> <entry>1</entry> <entry>1, 2</entry></row>
<row><entry>3</entry> <entry>2</entry> <entry>2</entry> <entry>1, 3</entry></row>
<row><entry>4</entry> <entry>5</entry> <entry>1</entry> <entry>1, 2, 4</entry></row>
<row><entry>5</entry> <entry>4</entry> <entry>2</entry> <entry>1, 2, 5</entry></row>
<row><entry>6</entry> <entry>7</entry> <entry>1</entry> <entry>1, 2, 5, 6</entry></row>
<row><entry>7</entry> <entry>6</entry> <entry>2</entry> <entry>1, 2, 5, 7</entry></row>
<row><entry>8</entry> <entry>9</entry> <entry>1</entry> <entry>1, 2, 5, 7, 8</entry></row>
<row><entry>9</entry> <entry>8</entry> <entry>2</entry> <entry>1, 2, 5, 7, 9</entry></row>
<row><entry>10</entry> <entry>9</entry> <entry>1</entry> <entry>1, 2, 5, 7, 9, 10</entry></row>
<row><entry>11</entry> <entry>9</entry> <entry>1</entry> <entry>1, 2, 5, 7, 9, 10, 11</entry></row>
<row><entry>...</entry> <entry>9</entry> <entry>1</entry> <entry>1, 2, 5, 7, 9, 10, 11, ...</entry></row>
</tbody>
</tgroup>
</table>
			
	<para>  Wymy¶lny schemat mo¿e zredukowaæ liczbê pracy, jednak mo¿e
    zwiêkszyæ ilo¶æ czynników, na które trzeba zwracaæ uwagê.
    Musisz zadecydowaæ czy warto.
	</para>

	<para>  <command>dump</command> ma wbudowan± obs³ugê poziomów,
	dla <command>tara</command> i <command>cpio</command> musisz to
    zaimplementowaæ za pomoc± odpowiednich skryptów.
	</para>

</sect1>

<sect1>
<title>Co zachowywaæ</title>

	<para>  Powiniene¶ zachowywaæ najwiêcej jak mo¿esz, g³ównym wyj±tkiem
    s± programy, które mog± byæ ³atwo reinstalowane,
	
		<footnote><para> Musisz zdecydowaæ co jest dla Ciebie ³atwe.
        Niektórzy uwa¿aj± ³atw± instalacjê z dziesi±tek dyskietek.
		</para></footnote>

	choæ i one posiadaj± pliki konfiguracyjne, które nale¿y zachowaæ.
    Innym wyj±tkiem jest system plików 
	<filename>/proc</filename>, który jest automatycznie tworzony
    przez j±dro i nie powiniene¶ go zachowywaæ.
	</para>

	<para>  Zachowywanie newsów, logów i innych rzeczy z
	<filename>/var</filename> zale¿y od Ciebie - musisz zdecydowaæ
    na czym Ci zale¿y.
	</para>

	<para>  Oczywistymi rzeczami do zachowywania s± pliki u¿ytkowników
	(<filename>/home</filename>), oraz konfiguracja systemu
	(<filename>/etc</filename> i inne pliki rozsiane po systemie).  </para>

</sect1>

<sect1>
<title>Skompresowane kopie zapasowe</title>

	<para>  Kopie zapasowe zajmuj± du¿o miejsca, które przecie¿
    kosztuje. Aby zredukowaæ objêto¶æ kopii mo¿na je kompresowaæ.
    Istnieje kilka sposobów. Niektóre programy maj± obs³ugê kompresji
    wbudowan±, np. opcja 
	<option>--gzip</option> (<option>-z</option>) <command>tara</command>
    przepuszcza archiwum przez <command>gzipa</command>.
	</para>
	
	<para>  Niestety skompresowane archiwa mog± czasami przysporzyæ
    k³opotów. Z powodu dzia³ania kompresji uszkodzenie jednego
    bitu mo¿e spowodowaæ utratê wszystkich danych. Niektóre programy
    posiadaj± mo¿liwo¶æ naprawy, jednak metody te s± zawodne przy du¿ej
    ilo¶ci b³êdów. Kopie zapasowe musz± byæ godne zaufania, a taka metoda
    kompresji nara¿a twoje dane.
	</para>
	
	<para>  Alternatywnie, mo¿na kompresowaæ ka¿dy plik z osobna. 
W najgorszym wypadku stracisz jeden plik, co przy nieskompresowanej
    kopii bezpieczeñstwa jest równie¿ mo¿liwe - to samo bezpieczeñstwo.
	Program <command>afio</command> (odmiana <command>cpio</command>) 
    potrafi tworzyæ takie kopie zapasowe.
    </para>
	
	<para> 
    Kompresja zajmuje czas, przez co mo¿e spowodowaæ zatrzymanie ta¶my.
	
		<footnote><para> Je¿eli dane nie s± zapisywane w odpowiednim
        tempie ta¶ma zostaje zatrzymana, czyni±c proces kopiowania
        jeszcze wolniejszym.
		</para></footnote>
		
	Mo¿na to omin±æ poprzez buforowanie wyj¶cia (wewnêtrznie,
    je¿eli program jest na tyle sprytny, lub zewnêtrznie - za pomoc±
    innych programów). Mo¿e to stanowiæ du¿e utrudnienie na wolnych komputerach.
	</para>

</sect1>

</chapter>

<chapter>
<title>Utrzymywanie aktualnego czasu</title>

	<blockquote><para> <quote>Czas jest iluzj±. Czas lunchu podwójn±.
	</quote> (Douglas Adams.)</para></blockquote>

	<para>  Rozdzia³ opisuje jak utrzymywaæ aktualny czas,
    co nale¿y zrobiæ aby unikn±æ k³opotów. Zazwyczaj nic nie musisz
    robiæ, jednak powiniene¶ rozumieæ zasadê dzia³ania.
	</para>

<sect1>
<title>Strefy czasowe</title>

	<para>  Mierzenie czasu opiera siê na, zasadniczo regularnym,
    fenomenie przyrody - dniu i nocy.
    Totalny czas trwania obu jest sta³y, jednak¿e poszczególne okresy
    maj± zmienn± d³ugo¶æ. Jedn± z prostych sta³ych jest po³udnie.
	</para>

	<para>  Po³udnie to czas dnia, w którym S³oñce jest w najwy¿szej
    pozycji. Poniewa¿ Ziemia jest okr±g³a,
	
		<footnote><para> Wed³ug najnowszych odkryæ.
		</para></footnote>
		
	po³udnie nastêpuje w ró¿nych miejscach o ró¿nych porach.
    To doprowadzi³o do powstania 
	<glossterm>lokalnego czasu</glossterm>. Ludzie mierz± czas w wielu
    jednostkach, z których wiêkszo¶æ podporz±dkowana jest
    naturalnym zjawiskom, np. takim jak po³udnie. Pozostaj±c w jednym
    miejscu nie zauwa¿asz ró¿nicy lokalnego czasu.
	</para>

	<para>  Chc±c porozumiewaæ siê na du¿e odleg³o¶ci musisz
    ustaliæ wspólny czas. Czas ten nazywa siê
	<glossterm>uniwersalnym</glossterm> (UT, lub UTC, w³a¶ciwie jest to
    Czas Greenwich, lub GMT, poniewa¿ jest to czas lokalny
    Greenwich w Anglii). W ten sposób ludzie mog± wyra¿aæ czas
    we wspólnej jednostce niezale¿nej od ich po³o¿enia.
	</para>
	
	<para>  Ka¿dy lokalny czas nazywany jest stref± czasow±. 
    Geograficy mogliby ustaliæ po³udnie we wszystkich miejscach
    o tej samej porze, jednak politycy nie. Z wielu powodów
    w wielu krajach u¿ywa siê czasu
	<glossterm>letniego i zimowego</glossterm>, co oznacza, ¿e
    w okre¶lonym momencie przestawia siê zegary aby pracowaæ
    przy ¶wietle dziennym (robi siê to na wiosnê i zimê).
	Niektóre kraje nie przyjê³y takiego schematu, do tego te które
    go przyjê³y zmieniaj± zasady przesuwania z roku na rok, w ten
    sposób czyni±c konwersjê ster trudnym zadaniem.
	</para>
	
	<para>  Strefy czasowe okre¶la siê nazw± po³o¿enia lub ró¿nic±
    od czasu GMT. W USA i innych krajach lokalne strefy
    posiadaj± nazwy i 3 literowe skróty. Skróty nie s± unikalne,
    wiêc nie powinny byæ u¿ywane bez nazwy kraju.
	Lepiej okre¶laæ czas jako, powiedzmy, Helsiñski, ni¿ Europy
    zachodniej, gdy¿ nie wszystkie kraje w Europie zachodniej
    przestrzegaj± tych samych regu³.
	</para>
	
	<para>  Linux ma specjalny pakiet znaj±cy wszystkie istniej±ce 
    strefy, który mo¿e byæ ³atwo zaktualizowany. Ka¿dy administrator
    musi wybraæ odpowiedni± strefê czasow±. Do tego, ka¿dy u¿ytkownik
    mo¿e ustawiæ swoj± w³asn± strefê; jest to wa¿ne gdy¿ poprzez 
    sieci rozleg³e na jednym komputerze mog± pracowaæ ludzie z ró¿nych
    zak±tków ¶wiata. W przypadku zmiany ustawieñ stref nale¿y zaktualizowaæ
    swój zestaw, poza tym nie trzeba przejmowaæ siê czasem.
	</para>

</sect1>

<sect1>
<title>Zegary sprzêtowe i programowe</title>

	<para>  Komputer osobisty posiada podtrzymywany bateryjnie zegar
    sprzêtowy. Bateria zapewnia ci±g³o¶æ trwania takiego zegara;
    za pomoc± BIOS-u lub systemu operacyjnego mo¿na go zmieniæ.
	</para>
	
	<para>  J±dro Linuxa utrzymuje swój w³asny, niezale¿ny
    zegar. Podczas startu systemu jest on ustawiany wed³ug
    wskazañ zegara sprzêtowego, po czym oba zegary dzia³aj± niezale¿nie.
    Linux utrzymuje swój w³asny zegar poniewa¿ ci±g³e odpytywanie
    sprzêtu jest wolne i skomplikowane.
	</para>

	<para>  Zegar j±dra zawsze wskazuje uniwersalny czas. W ten sposób
    j±dro nie musi wiedzieæ co to strefa czasowa. Zwiêksza to pewno¶æ
    dzia³ania zegara i upraszcza zmianê strefy czasowej. Ka¿dy
    proces zajmuje siê osobno konwersj± czasu (u¿ywaj±c standardowych
    narzêdzi rozprowadzanych wraz z informacjami o strefach).
	</para>
	
	<para>  Sprzêtowy zegar mo¿e byæ ustawiony wed³ug czasu lokalnego
    lub uniwersalnego. Lepiej jest ustawiæ go na czas uniwersalny,
    w ten sposób nie musisz przejmowaæ siê przej¶ciami na
    czas letni, lub zimowy (UTC nie posiada podzia³u "Daylight Savings Time").
    
	Niestety, niektóre systemy operacyjne (MS-DOS, Windows, OS/2) zak³adaj±,
    ¿e czas przechowywany przez BIOS jest czasem lokalnym.
    Linux obs³uguje oba przypadki, przy czym je¿eli zegar BIOS-u wskazuje
    czas lokalny musisz samodzielnie przechodziæ z czasu letniego na
    zimowy (i odwrotnie).
	</para>

</sect1>

<sect1>
<title>Wy¶wietlanie i zmienianie czasu</title>

	<para>  W dystrybucji Debian strefa czasowa ustawiania jest za pomoc±
	³±cza symbolicznego <filename>/etc/localtime</filename>.
	Odno¶nik wskazuje na plik zawieraj±cy dane dotycz±ce
    lokalnej strefy czasu. Pliki wszystkich stref przechowywane s± w
	<filename>/usr/lib/zoneinfo</filename>. Inne dystrybucje mog± to
    robiæ odmiennie.
	</para>
	
	<para>  U¿ytkownik mo¿e zmieniæ swoj± strefê czasu ustawiaj±c odpowiednio
    zmienn± TZ. Je¿eli nie jest ona ustawiona u¿ywana jest strefa systemu.
    Sk³adnia warto¶æ zmiennej TZ opisana jest w podrêczniku
	<function>tzset</function>.  </para>
	
	<para> 
	Program <command>date</command> pokazuje aktualn± datê i czas.
	
		<footnote><para> Pamiêtaj, ¿e program <command>time</command> 
        nie pokazuje aktualnego czasu.
		</para></footnote>
		
	Przyk³ad:

<screen>
<prompt>$</prompt> <userinput>date</userinput>
<computeroutput>czw lis 16 10:54:18 CET 2000</computeroutput>
<prompt>$</prompt>
</screen>

	Jak widaæ jest: czwartek, 16 listopada roku 2000, strefa czasu CET
	(CET, mo¿e np. oznaczaæ czas Europy ¶rodkowej).
	<command>date</command> mo¿e równie¿ pokazaæ czas uniwersalny:

<screen>
<prompt>$</prompt> <userinput>date -u</userinput>
<computeroutput>czw lis 16 09:55:52 UTC 2000</computeroutput>
<prompt>$</prompt>
</screen>

	Za pomoc± <command>date</command> mo¿na zmieniæ wewnêtrzny zegar j±dra:

<screen>
<prompt>#</prompt> <userinput>date 11162157</userinput>
<computeroutput>czw lis 16 21:57:00 CET 2000</computeroutput>
<prompt>#</prompt> <userinput>date</userinput>
<computeroutput>czw lis 16 21:57:02 CET 2000</computeroutput>
<prompt>#</prompt>
</screen>

	Zajrzyj do strony podrêcznika programu <command>date</command>;
    sk³adnia wywo³ania jest nieco skomplikowana. Tylko root mo¿e ustawiæ
    czas; ka¿dy u¿ytkownik mo¿e ustawiæ strefê czasu, jednak zegar
    dla ka¿dego z nich pozostaje taki sam.
	</para>
	
	<para>  <command>date</command> pokazuje tylko datê zegara systemowego.
    Poleceniem <command>clock</command> mo¿esz zsynchronizowaæ zegary
    sprzêtowy i programowy. Je¿eli musisz ustawiæ oba zegary, najpierw
    ustaw systemowy, po czym zaktualizuj zegar sprzêtowy
	(<command>clock -w</command>).  </para>

	<para>  Opcja <option>-u</option> powiadamia <command>clock</command>,
    ¿e zegar sprzêtowy wskazuje czas uniwersalny.
	<emphasis>Musisz</emphasis> poprawnie u¿ywaæ opcjê <option>-u</option>.
    W innym przypadku twój komputer nie bêdzie zna³ aktualnego czasu.
	</para>

	<para>  Zegary powinny byæ zmieniane ostro¿nie. Wiele programów
    Unixa zale¿y od czasu (poprawno¶ci jego up³ywu), dla przyk³adu:
	demon <command>cron</command>.
	Je¿eli zmienisz zegar demon nie bêdzie wiedzia³ czy uruchomi³ dane
    zadanie, czy te¿ nale¿y to zrobiæ. Na pewnym wczesnym Uniksie kto¶
    przestawi³ zegar 20 lat do przodu, 
	<command>cron</command> chcia³ nadrobiæ zaleg³o¶ci uruchamiaj±c
    wszystkie zaleg³e prace dla okresu 20 lat.
	Aktualne wersje <command>crona</command> obs³uguj± tak± sytuacjê
    poprawnie, jednak powiniene¶ byæ ostro¿ny. Du¿e skoki do przodu, lub
    do ty³u s± niebezpieczniejsze od powolnego posuwania siê w danym kierunku.
	</para>

</sect1>

<sect1>
<title>Kiedy czas jest niepoprawny</title>

	<para>  Zegar systemowy utrzymywany jest za pomoc± okresowego
	<glossterm>przerwania zegarowego</glossterm> PC. Je¿eli
    system operacyjny wykonuje zbyt wiele zadañ obs³u¿enie przerwania
    mo¿e mu zaj±æ zbyt du¿o czasu (zegar zaczyna siê pó¼niæ).
    Zegar sprzêtowy dzia³a niezale¿nie, dlatego zazwyczaj
    wskazuje poprawniejszy czas. Je¿eli czêsto uruchamiasz komputer
    (co dotyczy wiêkszo¶ci komputerów nie bêd±cych serwerami) nie masz
    po co siê martwiæ poprawno¶ci± zegara systemowego.
	</para>
	
	<para>  Je¿eli musisz zmieniæ zegar sprzêtowy mo¿esz:
	zrestartowaæ komputer i zmieniæ ustawienia BIOS-u (w ten
    sposób unikniesz wszystkich k³opotów zwi±zanych z nag³± zmian± czasu),
    zrobiæ to za pomoc± <command>date</command> i <command>clock</command>
    (w tej kolejno¶ci), w tym wypadku powiniene¶ byæ gotowy do restartu je¿eli
    co¶ zacznie siê dziwnie zachowywaæ.
	</para>

	<para>  Sieciowy komputer (nawet w przypadku modemu) mo¿e porównywaæ
    swój zegar z zegarem komputera utrzymuj±cego bardzo aktualny czasu.
    Mo¿na to osi±gn±æ przy u¿yciu <command>rdate</command>, lub
	<command>netdate</command>. Oba programy sprawdzaj± czas
    zdalnego komputera (<command>netdate</command> mo¿e sprawdzaæ czas na
    kilku z nich) i ustawiaj± odpowiednio czas lokalny. U¿ywaj±c regularnie
    jednego z tych poleceñ zapewnisz sobie aktualny czas.
	</para>

	<para>  XXX napisz co¶ m±drego o NTP. </para>

</sect1>

</chapter>

<glossary>
<title>S³owniczek (DRAFT)</title>

	<blockquote><para> <quote>
    Bibliotekarz Niewidzianego Uniwersytetu jednostronnie
    zdecydowa³ siê poszerzyæ wiedzê tworz±c Orang-utano/Ludzki s³ownik.
    Pracowa³ ca³e trzy miesi±ce. Nie by³o ³atwo.
    Zaszed³ tak daleko jak "Oook".</quote>
	(Terry Pratchett, ``Men At Arms'')</para></blockquote>

	<para>  Jest to krótka lista definicji, które s± zwi±zane z Linuxem i
    administrowaniem systemami.
	</para>

	<glossentry>
	<glossterm>ambicja</glossterm>
	<glossdef><para> 
	Akt tworzenia ¶miesznych sentencji w nadziei, ¿e znajd± siê w 
    Linuxowym zbiorze fortunek.
	</para></glossdef>
	</glossentry>

	<glossentry>
	<glossterm>aplikacja</glossterm>
	<glossdef><para> 
    Oprogramowanie wykonuj±ce po¿yteczn± czynno¶æ. Komputery kupuje siê po
    to aby otrzymywaæ rezultaty dzia³ania takich programów.
	Zobacz równie¿: program systemowy, system operacyjny.
	</para></glossdef>
	</glossentry>
	
	<glossentry>
	<glossterm>demon</glossterm>
	<glossdef><para> 
    Proces pracuj±cy w tle, najczê¶ciej niezauwa¿alnie, a¿ do czasu zbudzenia.
	Dla przyk³adu: demon <command>update</command> budzi siê co
    30 sekund i zapisuje dane (z cache'u) na dysku; demon
	<command>sendmail</command> budzi siê gdy kto¶ wysy³a pocztê.
	</para></glossdef>
	</glossentry>

	<glossentry>
	<glossterm>system plików</glossterm>
	<glossdef><para> 
    Metody i struktury danych, które system operacyjny u¿ywa aby
    przechowywaæ pliki na dysku. Czêsto u¿ywane w znaczeniu
    partycji lub dysku zawieraj±cego pliki.
	</para></glossdef>
	</glossentry>

	<glossentry>
	<glossterm>j±dro</glossterm>
	<glossdef><para> 
    Czê¶æ systemu operacyjnego, która zapewnia wspó³pracê ze sprzêtem
    i wspó³dzielenie zasobów. Sprawd¼ has³o: program systemowy.
	</para></glossdef>
	</glossentry>

	<glossentry>
	<glossterm>system operacyjny</glossterm>
	<glossdef><para> 
    Program, który rozdziela zasoby komputera (czas procesora,
    pamiêæ, powierzchniê dysku, itd. ) pomiêdzy u¿ytkowników i ich programy.
	W celu zachowania bezpieczeñstwa kontroluje dostêp do systemu.
    Zobacz: j±dro, program systemowy, aplikacja.
	</para></glossdef>
	</glossentry>

	<glossentry>
	<glossterm>wywo³anie systemowe</glossterm>
	<glossdef><para> 
    Us³uga oferowana programom przez j±dro. Zajrzyj do sekcji 2
    podrêcznika.
	</para></glossdef>
	</glossentry>

	<glossentry>
	<glossterm>program systemowy</glossterm>
	<glossdef><para> 
    Programy implementuj±ce wysoki poziom funkcjonalno¶ci systemu operacyjnego,
    np.: rzeczy, które s± niezale¿ne od sprzêtu. Czêsto wymagaj± specjalnych
    przywilejów. Zobacz: aplikacja, j±dro, system operacyjny.
	</para></glossdef>
	</glossentry>

</glossary>


</book>

